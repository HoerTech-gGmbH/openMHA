function sLib = libfitadaptor()
% LIBFITADAPTOR - function handle library
%
% Usage:
% libfitadaptor()
%
% Help to function "fun" can be accessed by calling
% fitadaptor.help.fun()
%

% This file was generated by "bake_mlib fitadaptor".
% Do not edit! Edit sources fitadaptor_*.m instead.
%
% Date: 15-Jun-2017 11:03:58
sLib = struct;
sLib.OHCcomp_gt2mha = @fitadaptor_OHCcomp_gt2mha;
sLib.help.OHCcomp_gt2mha = @help_OHCcomp_gt2mha;
sLib.OHCcomp_mha2fitmodel = @fitadaptor_OHCcomp_mha2fitmodel;
sLib.help.OHCcomp_mha2fitmodel = @help_OHCcomp_mha2fitmodel;
sLib.dc_gt2mha = @fitadaptor_dc_gt2mha;
sLib.help.dc_gt2mha = @help_dc_gt2mha;
sLib.dc_mha2fitmodel = @fitadaptor_dc_mha2fitmodel;
sLib.help.dc_mha2fitmodel = @help_dc_mha2fitmodel;
sLib.dc_simple_gt2mha = @fitadaptor_dc_simple_gt2mha;
sLib.help.dc_simple_gt2mha = @help_dc_simple_gt2mha;
sLib.dc_simple_mha2fitmodel = @fitadaptor_dc_simple_mha2fitmodel;
sLib.help.dc_simple_mha2fitmodel = @help_dc_simple_mha2fitmodel;
sLib.equalize_gt2mha = @fitadaptor_equalize_gt2mha;
sLib.help.equalize_gt2mha = @help_equalize_gt2mha;
sLib.equalize_mha2fitmodel = @fitadaptor_equalize_mha2fitmodel;
sLib.help.equalize_mha2fitmodel = @help_equalize_mha2fitmodel;
sLib.essex_aid_gt2mha = @fitadaptor_essex_aid_gt2mha;
sLib.help.essex_aid_gt2mha = @help_essex_aid_gt2mha;
sLib.essex_aid_mha2fitmodel = @fitadaptor_essex_aid_mha2fitmodel;
sLib.help.essex_aid_mha2fitmodel = @help_essex_aid_mha2fitmodel;
sLib.gaintable_gt2mha = @fitadaptor_gaintable_gt2mha;
sLib.help.gaintable_gt2mha = @help_gaintable_gt2mha;
sLib.gaintable_mha2fitmodel = @fitadaptor_gaintable_mha2fitmodel;
sLib.help.gaintable_mha2fitmodel = @help_gaintable_mha2fitmodel;
sLib.mdc_gt2mha = @fitadaptor_mdc_gt2mha;
sLib.help.mdc_gt2mha = @help_mdc_gt2mha;
sLib.mdc_mha2fitmodel = @fitadaptor_mdc_mha2fitmodel;
sLib.help.mdc_mha2fitmodel = @help_mdc_mha2fitmodel;
sLib.ohc_comp_gt2mha = @fitadaptor_ohc_comp_gt2mha;
sLib.help.ohc_comp_gt2mha = @help_ohc_comp_gt2mha;
sLib.ohc_comp_mha2fitmodel = @fitadaptor_ohc_comp_mha2fitmodel;
sLib.help.ohc_comp_mha2fitmodel = @help_ohc_comp_mha2fitmodel;
sLib.ohc_comp_simple_gt2mha = @fitadaptor_ohc_comp_simple_gt2mha;
sLib.help.ohc_comp_simple_gt2mha = @help_ohc_comp_simple_gt2mha;
sLib.ohc_comp_simple_mha2fitmodel = @fitadaptor_ohc_comp_simple_mha2fitmodel;
sLib.help.ohc_comp_simple_mha2fitmodel = @help_ohc_comp_simple_mha2fitmodel;
sLib.ohc_efficient_gt2mha = @fitadaptor_ohc_efficient_gt2mha;
sLib.help.ohc_efficient_gt2mha = @help_ohc_efficient_gt2mha;
sLib.ohc_efficient_mha2fitmodel = @fitadaptor_ohc_efficient_mha2fitmodel;
sLib.help.ohc_efficient_mha2fitmodel = @help_ohc_efficient_mha2fitmodel;
sLib.ohc_gt2mha = @fitadaptor_ohc_gt2mha;
sLib.help.ohc_gt2mha = @help_ohc_gt2mha;
sLib.ohc_mha2fitmodel = @fitadaptor_ohc_mha2fitmodel;
sLib.help.ohc_mha2fitmodel = @help_ohc_mha2fitmodel;
sLib.ohcsimple_gt2mha = @fitadaptor_ohcsimple_gt2mha;
sLib.help.ohcsimple_gt2mha = @help_ohcsimple_gt2mha;
sLib.ohcsimple_mha2fitmodel = @fitadaptor_ohcsimple_mha2fitmodel;
sLib.help.ohcsimple_mha2fitmodel = @help_ohcsimple_mha2fitmodel;
sLib.spsmft_gt2mha = @fitadaptor_spsmft_gt2mha;
sLib.help.spsmft_gt2mha = @help_spsmft_gt2mha;
sLib.spsmft_mha2fitmodel = @fitadaptor_spsmft_mha2fitmodel;
sLib.help.spsmft_mha2fitmodel = @help_spsmft_mha2fitmodel;
assignin('caller','fitadaptor',sLib);


function sCfg = fitadaptor_OHCcomp_gt2mha( sGt, sMHACfg )
  if ~isfield(sGt,'basilar_io')
    error('The selected gainrule does not provide basilar membrane IO parameters');
  end
  sCfg = struct;
  % one row for each level, one column for each frequency band:
  vsChPlug='LR';
  csPar={'gmax_n','gmax_i','l_passive','c_slope'};
  for k=1:2
    sChGt=sGt.side(min(k,numel(sGt.side)));
    sChPlug = vsChPlug(k);
    for sPar=csPar
      sCfg.([sChPlug,'_',sPar{:}]) = sGt.basilar_io.(sChGt).(sPar{:});
    end
  end
  sCfg.gainrule = sGt.fit.gainrule;
  sCfg.clientid = sGt.fit.audprof.client_id;


function help_OHCcomp_gt2mha
disp([' OHCCOMP_GT2MHA - one row for each level, one column for each frequency band:',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.OHCcomp_gt2mha( sGt, sMHACfg );',char(10),'',char(10),'']);


function sFitModel = fitadaptor_OHCcomp_mha2fitmodel( sMHACfg )
  %sMHACfg.IFest
  sFitModel = struct;
  sFitModel.frequencies = sMHACfg.cf;
  cf = sFitModel.frequencies;
  if length(cf) == 1
    ef = [125,8000];
  else
    ef = sqrt(cf(2:end).*cf(1:end-1));
    ef = [cf(1)*cf(1)/ef(1),ef,cf(end)*cf(end)/ef(end)];
  end
  sFitModel.edge_frequencies = ef;
  sFitModel.levels = [0:1:100];
  sFitModel.channels = sMHACfg.mhaconfig_in.channels;


function help_OHCcomp_mha2fitmodel
disp([' OHCCOMP_MHA2FITMODEL - sMHACfg.IFest',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sFitModel = fitadaptor.OHCcomp_mha2fitmodel( sMHACfg );',char(10),'',char(10),'']);


function sCfg = fitadaptor_dc_gt2mha( sGt, sMHACfg )
  sCfg = struct;
  sCfg.gtdata = [];
  sCfg.gtmin = [];
  sCfg.gtstep = [];
  for ch=sGt.side
    sCfg.gtdata = [sCfg.gtdata;sGt.(ch)'];
    sCfg.gtmin = [sCfg.gtmin,repmat(min(sGt.levels),[1,length(sGt.frequencies)])];
    sCfg.gtstep = [sCfg.gtstep,repmat(1,[1,length(sGt.frequencies)])];
  end
  sCfg.gainrule = sGt.fit.gainrule;
  sCfg.clientid = sGt.fit.audprof.client_id;


function help_dc_gt2mha
disp([' DC_GT2MHA - ',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.dc_gt2mha( sGt, sMHACfg );',char(10),'']);


function sFitModel = fitadaptor_dc_mha2fitmodel( sMHACfg )
  sFitModel = struct;
  sFitModel.frequencies = sMHACfg.cf;
  sFitModel.edge_frequencies = sMHACfg.ef;
  sFitModel.levels = -10:1:110;
  sFitModel.channels = sMHACfg.mhaconfig_in.channels/length(sMHACfg.cf);


function help_dc_mha2fitmodel
disp([' DC_MHA2FITMODEL - ',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sFitModel = fitadaptor.dc_mha2fitmodel( sMHACfg );',char(10),'']);


function sCfg = fitadaptor_dc_simple_gt2mha( sGt, sMHACfg )
  sCfg = struct;
  % one row for each level, one column for each frequency band:
  sCfg.g50 = [];
  sCfg.g80 = [];
  sCfg.expansion_threshold = [];
  sCfg.expansion_slope = [];
  for ch=sGt.side
    sCfg.g50 = [sCfg.g50,sGt.(ch)(1,:)];
    sCfg.g80 = [sCfg.g80,sGt.(ch)(2,:)];
    sCfg.expansion_threshold = [sCfg.expansion_threshold,sGt.noisegate.(ch).level(:)'];
    sCfg.expansion_slope = [sCfg.expansion_slope,sGt.noisegate.(ch).slope(:)'];
  end
  sCfg.gainrule = sGt.fit.gainrule;
  sCfg.clientid = sGt.fit.audprof.client_id;


function help_dc_simple_gt2mha
disp([' DC_SIMPLE_GT2MHA - one row for each level, one column for each frequency band:',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.dc_simple_gt2mha( sGt, sMHACfg );',char(10),'',char(10),'']);


function sFitModel = fitadaptor_dc_simple_mha2fitmodel( sMHACfg )
  sFitModel = struct;
  sFitModel.frequencies = sMHACfg.cf;
  sFitModel.edge_frequencies = sMHACfg.ef;
  sFitModel.levels = [50 80];
  sFitModel.channels = sMHACfg.mhaconfig_in.channels/length(sMHACfg.cf);


function help_dc_simple_mha2fitmodel
disp([' DC_SIMPLE_MHA2FITMODEL - ',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sFitModel = fitadaptor.dc_simple_mha2fitmodel( sMHACfg );',char(10),'']);


function sCfg = fitadaptor_equalize_gt2mha( sGt, sMHACfg )
  sCfg = struct;
  fftlen = sMHACfg.mhaconfig_in.fftlen;
  fftfreqs = [0:fftlen] / fftlen * sMHACfg.mhaconfig_in.srate;
  bins = floor(fftlen/2)+1;
  % one row for each level, one column for each frequency band:
  sCfg.gains = [];
  for ch=sGt.side
    sCfg.gains = [sCfg.gains;10.^(sGt.(ch)(2,:)/20)];
  end


function help_equalize_gt2mha
disp([' EQUALIZE_GT2MHA - one row for each level, one column for each frequency band:',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.equalize_gt2mha( sGt, sMHACfg );',char(10),'',char(10),'']);


function sFitModel = fitadaptor_equalize_mha2fitmodel( sMHACfg )
  sFitModel = struct;
  fftlen = sMHACfg.mhaconfig_in.fftlen;
  srate = sMHACfg.mhaconfig_in.srate;
  fftfreqs = [1:fftlen] / fftlen * srate;
  bins = floor(fftlen/2)+1;
  binfreqs = fftfreqs(1:bins);
  sFitModel.frequencies = binfreqs;
  sFitModel.edge_frequencies = [1,mean([binfreqs(1:end-1);binfreqs(2:end)]),srate/2];
  sFitModel.levels = [0 65];
  sFitModel.channels = sMHACfg.mhaconfig_in.channels;


function help_equalize_mha2fitmodel
disp([' EQUALIZE_MHA2FITMODEL - ',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sFitModel = fitadaptor.equalize_mha2fitmodel( sMHACfg );',char(10),'']);


function sCfg = fitadaptor_essex_aid_gt2mha( sGt, sMHACfg )
  if ~isfield(sGt,'essex_io')
    error('The selected gainrule does not provide Essex IO parameters');
  end
  sCfg = struct;

  sCfg.inst_compr_threshold = sGt.essex_io.tc;
  sCfg.gain = sGt.essex_io.gain;
  sCfg.moc_tc = sGt.essex_io.tm;
  sCfg.moc_factor = sGt.essex_io.moc_factor;
  sCfg.moc_tc = sGt.essex_io.moc_tau;



function help_essex_aid_gt2mha
disp([' ESSEX_AID_GT2MHA - ',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.essex_aid_gt2mha( sGt, sMHACfg );',char(10),'']);


function sFitModel = fitadaptor_essex_aid_mha2fitmodel( sMHACfg )

  sFitModel = struct;
  sFitModel.edge_frequencies = sMHACfg.edge_frequencies;
  sFitModel.frequencies = sqrt(sFitModel.edge_frequencies(2:end) .* ...
			       sFitModel.edge_frequencies(1:(end-1)));
  sFitModel.levels = [0:1:100];
  sFitModel.channels = sMHACfg.mhaconfig_in.channels;


function help_essex_aid_mha2fitmodel
disp([' ESSEX_AID_MHA2FITMODEL - ',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sFitModel = fitadaptor.essex_aid_mha2fitmodel( sMHACfg );',char(10),'']);


function sCfg = fitadaptor_gaintable_gt2mha( sGt, sMHACfg )
  sCfg = struct;
  % one row for each level, one column for each frequency band:
  switch sGt.side
    case 'l'
     sCfg.gain_L = sGt.l';
     sCfg.gain_R = sGt.l';
   case 'r'
    sCfg.gain_L = sGt.r';
    sCfg.gain_R = sGt.r';
   case 'lr'
    sCfg.gain_L = sGt.l';
    sCfg.gain_R = sGt.r';
   case 'rl'
    sCfg.gain_L = sGt.r';
    sCfg.gain_R = sGt.l';
  end
  sCfg.gainrule = sGt.fit.gainrule;
  sCfg.clientid = sGt.fit.audprof.client_id;


function help_gaintable_gt2mha
disp([' GAINTABLE_GT2MHA - one row for each level, one column for each frequency band:',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.gaintable_gt2mha( sGt, sMHACfg );',char(10),'',char(10),'']);


function sFitModel = fitadaptor_gaintable_mha2fitmodel( sMHACfg )
  sFitModel = struct;
  sFitModel.frequencies = sMHACfg.cf;
  cf = sFitModel.frequencies;
  if length(cf) == 1
    ef = [125,8000];
  else
    ef = sqrt(cf(2:end).*cf(1:end-1));
    ef = [cf(1)*cf(1)/ef(1),ef,cf(end)*cf(end)/ef(end)];
  end
  sFitModel.edge_frequencies = ef;
  sFitModel.levels = sMHACfg.Linput;
  sFitModel.channels = sMHACfg.mhaconfig_in.channels/length(sMHACfg.cf);


function help_gaintable_mha2fitmodel
disp([' GAINTABLE_MHA2FITMODEL - ',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sFitModel = fitadaptor.gaintable_mha2fitmodel( sMHACfg );',char(10),'']);


function sCfg = fitadaptor_mdc_gt2mha( sGt, sMHACfg )
  if ~isfield(sGt,'basilar_io')
    error('The selected gainrule does not provide basilar membrane IO parameters');
  end
  sCfg = struct;
  % one row for each level, one column for each frequency band:
  vsChPlug='LR';
  csPar={'gmax_n','gmax_i','l_passive','c_slope'};
  for k=1:2
    sChGt=sGt.side(min(k,numel(sGt.side)));
    sChPlug = vsChPlug(k);
    for sPar=csPar
      if k==1
	sCfg.basilar_io.(sPar{:}) = sGt.basilar_io.(sChGt).(sPar{:});
      else
	sCfg.basilar_io.(sPar{:}) = ...
	    [sCfg.basilar_io.(sPar{:}),	sGt.basilar_io.(sChGt).(sPar{:})];
      end
    end
  end


function help_mdc_gt2mha
disp([' MDC_GT2MHA - one row for each level, one column for each frequency band:',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.mdc_gt2mha( sGt, sMHACfg );',char(10),'',char(10),'']);


function sFitModel = fitadaptor_mdc_mha2fitmodel( sMHACfg )
  %sMHACfg.IFest
  sFitModel = struct;
  sFitModel.frequencies = sMHACfg.IFest.f_hz;
  cf = sFitModel.frequencies;
  if length(cf) == 1
    ef = [125,8000];
  else
    ef = sqrt(cf(2:end).*cf(1:end-1));
    ef = [cf(1)*cf(1)/ef(1),ef,cf(end)*cf(end)/ef(end)];
  end
  sFitModel.edge_frequencies = ef;
  sFitModel.levels = [0:1:100];
  sFitModel.channels = sMHACfg.mhaconfig_in.channels/numel(cf);


function help_mdc_mha2fitmodel
disp([' MDC_MHA2FITMODEL - sMHACfg.IFest',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sFitModel = fitadaptor.mdc_mha2fitmodel( sMHACfg );',char(10),'',char(10),'']);


function sCfg = fitadaptor_ohc_comp_gt2mha( sGt, sMHACfg )
  if ~isfield(sGt,'basilar_io')
    error('The selected gainrule does not provide basilar membrane IO parameters');
  end
  sCfg = struct;
  % one row for each level, one column for each frequency band:
  vsChPlug='LR';
  csPar={'gmax_n','gmax_i','l_passive','c_slope'};
  warning('works for 1 channel only! Do not use.')
  for k=1
    sChGt=sGt.side(min(k,numel(sGt.side)));
    sChPlug = vsChPlug(k);
    for sPar=csPar
      sCfg.basilar_io.(sPar{:}) = sGt.basilar_io.(sChGt).(sPar{:});
    end
  end


function help_ohc_comp_gt2mha
disp([' OHC_COMP_GT2MHA - one row for each level, one column for each frequency band:',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.ohc_comp_gt2mha( sGt, sMHACfg );',char(10),'',char(10),'']);


function sFitModel = fitadaptor_ohc_comp_mha2fitmodel( sMHACfg )
  %sMHACfg.IFest
  sFitModel = struct;
  sFitModel.frequencies = sMHACfg.IFest.f_hz;
  cf = sFitModel.frequencies;
  cf
  if length(cf) == 1
    ef = [125,8000];
  else
    ef = sqrt(cf(2:end).*cf(1:end-1));
    ef = [cf(1)*cf(1)/ef(1),ef,cf(end)*cf(end)/ef(end)];
  end
  sFitModel.edge_frequencies = ef;
  sFitModel.levels = [0:1:100];
  sFitModel.channels = sMHACfg.mhaconfig_in.channels/numel(cf);


function help_ohc_comp_mha2fitmodel
disp([' OHC_COMP_MHA2FITMODEL - sMHACfg.IFest',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sFitModel = fitadaptor.ohc_comp_mha2fitmodel( sMHACfg );',char(10),'',char(10),'']);


function sCfg = fitadaptor_ohc_comp_simple_gt2mha( sGt, sMHACfg )
  if ~isfield(sGt,'compression')
    error('The selected gainrule does not provide basilar membrane IO parameters');
  end
  sCfg = struct;
  % one row for each level, one column for each frequency band:
  vsChPlug='LR';
  csPar={'gain','l_kneepoint','c_slope'};
  warning('works for 1 channel only! Do not use.')
  for k=1
    sChGt=sGt.side(min(k,numel(sGt.side)));
    sChPlug = vsChPlug(k);
    for sPar=csPar
      sCfg.compression.(sPar{:}) = sGt.compression.(sChGt).(sPar{:});
    end
  end
  
  

function help_ohc_comp_simple_gt2mha
disp([' OHC_COMP_SIMPLE_GT2MHA - one row for each level, one column for each frequency band:',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.ohc_comp_simple_gt2mha( sGt, sMHACfg );',char(10),'',char(10),'']);


  function sFitModel = fitadaptor_ohc_comp_simple_mha2fitmodel( sMHACfg )

  sFitModel = struct;
  sFitModel.frequencies = sMHACfg.IFest.f_hz;
  cf = sFitModel.frequencies;
  cf
  if length(cf) == 1
    ef = [125,8000];
  else
    ef = sqrt(cf(2:end).*cf(1:end-1));
    ef = [cf(1)*cf(1)/ef(1),ef,cf(end)*cf(end)/ef(end)];
  end
  sFitModel.edge_frequencies = ef;
  sFitModel.levels = [0:1:100];
  sFitModel.channels = sMHACfg.mhaconfig_in.channels/numel(cf);


function help_ohc_comp_simple_mha2fitmodel
disp([' OHC_COMP_SIMPLE_MHA2FITMODEL - ',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'    sFitModel = fitadaptor.ohc_comp_simple_mha2fitmodel( sMHACfg );',char(10),'']);


function sCfg = fitadaptor_ohc_efficient_gt2mha( sGt, sMHACfg )
  if ~isfield(sGt,'basilar_io')
    error('The selected gainrule does not provide basilar membrane IO parameters');
  end
  sCfg = struct;
  % one row for each level, one column for each frequency band:
  vsChPlug='LR';
  csPar={'gmax_n','gmax_i','l_passive','c_slope'};
  %warning('works for 1 channel only! Do not use.')
  for k=1:2
    sChGt=sGt.side(min(k,numel(sGt.side)));
    sChPlug = vsChPlug(k);
    for sPar=csPar
      if k==1
	sCfg.basilar_io.(sPar{:}) = sGt.basilar_io.(sChGt).(sPar{:});
      else
	sCfg.basilar_io.(sPar{:}) = ...
	    [sCfg.basilar_io.(sPar{:}),	sGt.basilar_io.(sChGt).(sPar{:})];
      end
    end
  end


function help_ohc_efficient_gt2mha
disp([' OHC_EFFICIENT_GT2MHA - one row for each level, one column for each frequency band:',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.ohc_efficient_gt2mha( sGt, sMHACfg );',char(10),'',char(10),'']);


function sFitModel = fitadaptor_ohc_efficient_mha2fitmodel( sMHACfg )
  %sMHACfg.IFest
  sFitModel = struct;
  sFitModel.frequencies = sMHACfg.IFest.f_hz;
  cf = sFitModel.frequencies;
  if length(cf) == 1
    ef = [125,8000];
  else
    ef = sqrt(cf(2:end).*cf(1:end-1));
    ef = [cf(1)*cf(1)/ef(1),ef,cf(end)*cf(end)/ef(end)];
  end
  sFitModel.edge_frequencies = ef;
  sFitModel.levels = [0:1:100];
  sFitModel.channels = sMHACfg.mhaconfig_in.channels/numel(cf);


function help_ohc_efficient_mha2fitmodel
disp([' OHC_EFFICIENT_MHA2FITMODEL - sMHACfg.IFest',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sFitModel = fitadaptor.ohc_efficient_mha2fitmodel( sMHACfg );',char(10),'',char(10),'']);


function sCfg = fitadaptor_ohc_gt2mha( sGt, sMHACfg )
  if ~isfield(sGt,'basilar_io')
    error('The selected gainrule does not provide basilar membrane IO parameters');
  end
  sCfg = struct;
  % one row for each level, one column for each frequency band:
  vsChPlug='LR';
  csPar={'gmax_n','gmax_i','l_passive','c_slope'};
  for k=1:2
    sChGt=sGt.side(min(k,numel(sGt.side)));
    sChPlug = vsChPlug(k);
    for sPar=csPar
      sCfg.([sChPlug,'_basilar_io']).(sPar{:}) = sGt.basilar_io.(sChGt).(sPar{:});
    end
  end
  sCfg.gainrule = sGt.fit.gainrule;
  sCfg.clientid = sGt.fit.audprof.client_id;


function help_ohc_gt2mha
disp([' OHC_GT2MHA - one row for each level, one column for each frequency band:',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.ohc_gt2mha( sGt, sMHACfg );',char(10),'',char(10),'']);


function sFitModel = fitadaptor_ohc_mha2fitmodel( sMHACfg )
  %sMHACfg.IFest
  sFitModel = struct;
  sFitModel.frequencies = sMHACfg.cf;
  cf = sFitModel.frequencies;
  if length(cf) == 1
    ef = [125,8000];
  else
    ef = sqrt(cf(2:end).*cf(1:end-1));
    ef = [cf(1)*cf(1)/ef(1),ef,cf(end)*cf(end)/ef(end)];
  end
  sFitModel.edge_frequencies = ef;
  sFitModel.levels = [0:1:100];
  sFitModel.channels = sMHACfg.mhaconfig_in.channels;


function help_ohc_mha2fitmodel
disp([' OHC_MHA2FITMODEL - sMHACfg.IFest',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sFitModel = fitadaptor.ohc_mha2fitmodel( sMHACfg );',char(10),'',char(10),'']);


function sCfg = fitadaptor_ohcsimple_gt2mha( sGt, sMHACfg )
  if ~isfield(sGt,'compression')
    error('The selected gainrule does not provide parametrized IO function');
  end
  sCfg = struct;
  % one row for each level, one column for each frequency band:
  vsChPlug='LR';
  csPar={'gain','l_kneepoint','c_slope'};
  for k=1:2
    sChGt=sGt.side(min(k,numel(sGt.side)));
    sChPlug = vsChPlug(k);
    for sPar=csPar
      sCfg.([sChPlug,'_compression']).(sPar{:}) = sGt.compression.(sChGt).(sPar{:});
    end
  end
  sCfg.gainrule = sGt.fit.gainrule;
  sCfg.clientid = sGt.fit.audprof.client_id;


function help_ohcsimple_gt2mha
disp([' OHCSIMPLE_GT2MHA - one row for each level, one column for each frequency band:',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.ohcsimple_gt2mha( sGt, sMHACfg );',char(10),'',char(10),'']);


function sFitModel = fitadaptor_ohcsimple_mha2fitmodel( sMHACfg )
  %sMHACfg.IFest
  sFitModel = struct;
  sFitModel.frequencies = sMHACfg.cf;
  cf = sFitModel.frequencies;
  if length(cf) == 1
    ef = [125,8000];
  else
    ef = sqrt(cf(2:end).*cf(1:end-1));
    ef = [cf(1)*cf(1)/ef(1),ef,cf(end)*cf(end)/ef(end)];
  end
  sFitModel.edge_frequencies = ef;
  sFitModel.levels = [0:1:100];
  sFitModel.channels = sMHACfg.mhaconfig_in.channels;


function help_ohcsimple_mha2fitmodel
disp([' OHCSIMPLE_MHA2FITMODEL - sMHACfg.IFest',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sFitModel = fitadaptor.ohcsimple_mha2fitmodel( sMHACfg );',char(10),'',char(10),'']);


function sCfg = fitadaptor_spsmft_gt2mha( sGt, sMHACfg )
  sCfg = struct;
  % one row for each level, one column for each frequency band:
  switch sGt.side
    case 'l'
     sCfg.GT.gain_L = sGt.l';
     sCfg.GT.gain_R = sGt.l';
   case 'r'
    sCfg.GT.gain_L = sGt.r';
    sCfg.GT.gain_R = sGt.r';
   case 'lr'
    sCfg.GT.gain_L = sGt.l';
    sCfg.GT.gain_R = sGt.r';
   case 'rl'
    sCfg.GT.gain_L = sGt.r';
    sCfg.GT.gain_R = sGt.l';
  end
  sCfg.GT.gainrule = sGt.fit.gainrule;
  sCfg.GT.clientid = sGt.fit.audprof.client_id;


function help_spsmft_gt2mha
disp([' SPSMFT_GT2MHA - one row for each level, one column for each frequency band:',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sCfg = fitadaptor.spsmft_gt2mha( sGt, sMHACfg );',char(10),'',char(10),'']);


function sFitModel = fitadaptor_spsmft_mha2fitmodel( sMHACfg )
  sFitModel = struct;
  sFitModel.frequencies = sMHACfg.IFest.f_hz;
  cf = sFitModel.frequencies;
  if length(cf) == 1
    ef = [125,8000];
  else
    ef = sqrt(cf(2:end).*cf(1:end-1));
    ef = [cf(1)*cf(1)/ef(1),ef,cf(end)*cf(end)/ef(end)];
  end
  sFitModel.edge_frequencies = ef;
  sFitModel.levels = sMHACfg.GT.Linput;
  sFitModel.channels = sMHACfg.mhaconfig_in.channels/length(sMHACfg.IFest.f_hz);


function help_spsmft_mha2fitmodel
disp([' SPSMFT_MHA2FITMODEL - ',char(10),'',char(10),' Usage:',char(10),'  fitadaptor = libfitadaptor();',char(10),'  sFitModel = fitadaptor.spsmft_mha2fitmodel( sMHACfg );',char(10),'']);


