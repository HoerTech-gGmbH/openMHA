function sLib = libsd()
% LIBSD - function handle library
%
% Usage:
% libsd()
%
% Help to function "fun" can be accessed by calling
% sd.help.fun()
%

% This file was generated by "bake_mlib sd".
% Do not edit! Edit sources sd_*.m instead.
%
% Date: 20-Apr-2017 16:56:17
sLib = struct;
sLib.anovan = @sd_anovan;
sLib.help.anovan = @help_anovan;
sLib.average = @sd_average;
sLib.help.average = @help_average;
sLib.col2par = @sd_col2par;
sLib.help.col2par = @help_col2par;
sLib.compactval = @sd_compactval;
sLib.help.compactval = @help_compactval;
sLib.csv = @sd_csv;
sLib.help.csv = @help_csv;
sLib.deltaref = @sd_deltaref;
sLib.help.deltaref = @help_deltaref;
sLib.eval = @sd_eval;
sLib.help.eval = @help_eval;
sLib.eval2 = @sd_eval2;
sLib.help.eval2 = @help_eval2;
sLib.fun = @sd_fun;
sLib.help.fun = @help_fun;
sLib.getdim = @sd_getdim;
sLib.help.getdim = @help_getdim;
sLib.getfield = @sd_getfield;
sLib.help.getfield = @help_getfield;
sLib.getvalues = @sd_getvalues;
sLib.help.getvalues = @help_getvalues;
sLib.latex_tabular = @sd_latex_tabular;
sLib.help.latex_tabular = @help_latex_tabular;
sLib.merge = @sd_merge;
sLib.help.merge = @help_merge;
sLib.mergepar = @sd_mergepar;
sLib.help.mergepar = @help_mergepar;
sLib.par2col = @sd_par2col;
sLib.help.par2col = @help_par2col;
sLib.permval = @sd_permval;
sLib.help.permval = @help_permval;
sLib.plot = @sd_plot;
sLib.help.plot = @help_plot;
sLib.plot_histo = @sd_plot_histo;
sLib.help.plot_histo = @help_plot_histo;
sLib.plotwizzard = @sd_plotwizzard;
sLib.help.plotwizzard = @help_plotwizzard;
sLib.posthoc = @sd_posthoc;
sLib.help.posthoc = @help_posthoc;
sLib.readxls = @sd_readxls;
sLib.help.readxls = @help_readxls;
sLib.renamefield = @sd_renamefield;
sLib.help.renamefield = @help_renamefield;
sLib.reorder_datacol = @sd_reorder_datacol;
sLib.help.reorder_datacol = @help_reorder_datacol;
sLib.restrict = @sd_restrict;
sLib.help.restrict = @help_restrict;
sLib.result2par = @sd_result2par;
sLib.help.result2par = @help_result2par;
sLib.rmcol = @sd_rmcol;
sLib.help.rmcol = @help_rmcol;
sLib.rminf = @sd_rminf;
sLib.help.rminf = @help_rminf;
sLib.rmnan = @sd_rmnan;
sLib.help.rmnan = @help_rmnan;
sLib.squeeze = @sd_squeeze;
sLib.help.squeeze = @help_squeeze;
sLib.strrepval = @sd_strrepval;
sLib.help.strrepval = @help_strrepval;
sLib.struct2parstruct = @sd_struct2parstruct;
sLib.help.struct2parstruct = @help_struct2parstruct;
sLib.uniquepar = @sd_uniquepar;
sLib.help.uniquepar = @help_uniquepar;
assignin('caller','sd',sLib);


function [P,T,STATS,TERMS] = sd_anovan( sData, DataCol, vParCol, varargin )
% anovan version of struct data - see anovan for help
  Y = sData.data(:,DataCol);
  GROUP = {};
  for k=vParCol
    GROUP{end+1} = sData.values{k}(sData.data(:,k))';
  end
  [P,T,STATS,TERMS] = anovan(Y,GROUP,'varnames',sData.fields(vParCol), varargin{:});


function help_anovan
disp([' ANOVAN - version of struct data - see  for help',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  [P,T,STATS,TERMS] = sd.anovan( sData, DataCol, vParCol, varargin );',char(10),'',char(10),'']);


function [s, csFields] = sd_average( s, vkField, cFunc )
% calculate average across specified fields
%
% Usage:
% [s, csFields] = sd_average( s, vkField [, cFunc ] )
%
% Input arguments:
% s       : data structure.
% vkField : field numbers to calculate the average.
% cFunc   : cell array of function handles (optional).
%           Functions may take a matrix of values as input and must
%           return a row vector (e.g., '{@mean}').
%
% Return values:
% s  : modified data structure with extra data fields 'N' (number
%      of fields) and the processed value of each data column for 
%      each specified function (e.g., 'mean(Y)').
% csFields : names of processed fields.
%
% Author: Giso Grimm
% Date: 11/2008
  ;
  if nargin < 3
    cFunc = {@mean,@std};
  end
  if ischar(vkField)
    vkField = strmatch(vkField,s.fields,'exact');
  end
  % get lengths:
  nParIn = length(s.values);
  nFieldsIn = length(s.fields);
  nData = nFieldsIn-nParIn;
  %
  csFields = s.fields(vkField);
  ridx = setdiff(1:nParIn,vkField);
  mKeep = unique(s.data(:,ridx),'rows');
  % create field names:
  sOut.fields = [s.fields(ridx),'N'];
  sOut.values = s.values(ridx);
  for kFun=1:length(cFunc)
    for kData=1:nData
      sOut.fields{end+1} = sprintf('%s(%s)',func2str(cFunc{kFun}),s.fields{nParIn+kData});
    end
  end
  % select data and calc functions:
  sOut.data = zeros(0,size(mKeep,2)+1+length(cFunc)*nData);
  for kKeep=1:size(mKeep,1)
    idx = find(ismember(s.data(:,ridx),mKeep(kKeep,:),'rows'));
    mSubData = s.data(idx,(nParIn+1):end);
    mRes = length(idx);
    for kFun=1:length(cFunc)
      mRes = [mRes,cFunc{kFun}(mSubData)];
    end
    sOut.data(end+1,:) = [mKeep(kKeep,:),mRes];
  end
  s = sOut;

function help_average
disp([' AVERAGE - calculate  across specified fields',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  [s, csFields] = sd.average( s, vkField, cFunc );',char(10),'',char(10),'',char(10),' Usage:',char(10),' [s, csFields] = sd_average( s, vkField [, cFunc ] )',char(10),'',char(10),' Input arguments:',char(10),' s       : data structure.',char(10),' vkField : field numbers to calculate the average.',char(10),' cFunc   : cell array of function handles (optional).',char(10),'           Functions may take a matrix of values as input and must',char(10),'           return a row vector (e.g., ''{@mean}'').',char(10),'',char(10),' Return values:',char(10),' s  : modified data structure with extra data fields ''N'' (number',char(10),'      of fields) and the processed value of each data column for ',char(10),'      each specified function (e.g., ''mean(Y)'').',char(10),' csFields : names of processed fields.',char(10),'',char(10),' Author: Giso Grimm',char(10),' Date: 11/2008',char(10),'']);


function [sOut,mFields] = sd_col2par( sIn, sParName, cValues, csDataNames )
% convert multiple data columns into a new parameter column
% sParName : new parameter column name
% cValues : values of new parameter column
% csDataNames : names of resulting data columns
%
%Note: 
% If field order is {'a1','a2','a3','b1','b2','b3'} then use
%
% sOut = sd.col2par(sIn,'numeric',{'1','2','3'},{'a','b'});
%
% or
%
% sOut = sd.col2par(sIn,'numeric',1:3,{'a','b'});
%
% This means that the new parameter field must be in interleaved
% order in the input data fields.
%
% Check consistency of mFields to avoid unexpected results.
  ;
  % get number of fields:
  nParIn = length(sIn.values);
  nDataIn = size(sIn.data,2)-nParIn;
  nElem = size(sIn.data,1);
  nParElem = length(cValues);
  nDataOut = length(csDataNames);
  if( length(csDataNames) * length(cValues) ~= nDataIn )
    error(sprintf(['Number of values (%d) times number of remaining data' ...
		   ' fields (%d) must be number of input data fields' ...
		   ' (%d).'],length(csDataNames),length(cValues),nDataIn));
  end
  mParBlock = repmat([sIn.data(:,1:nParIn),zeros(nElem,1)],[nParElem,1]);
  mDataIn = sIn.data(:,nParIn+[1:nDataIn]);
  for k=1:nParElem
    mParBlock([1:nElem]+(k-1)*nElem,end) = k;
  end
  mDataOut = reshape(mDataIn,[nElem*nParElem,nDataOut]);
  sOut = struct;
  for k=1:length(csDataNames)
    if strcmp(class(csDataNames{k}),'function_handle')
      csDataNames{k} = func2str(csDataNames{k});
    end
  end
  sOut.fields = [sIn.fields(1:nParIn),{sParName},csDataNames];
  sOut.values = [sIn.values,{cValues}];
  sOut.data = [mParBlock,mDataOut];
  idx = find(~any(~isnan(mDataOut),2));
  sOut.data(idx,:) = [];
  mFields = reshape(sIn.fields(nParIn+[1:nDataIn]),[nParElem,nDataOut]);

function help_col2par
disp([' COL2PAR - convert multiple data columns into a new parameter column',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  [sOut,mFields] = sd.col2par( sIn, sParName, cValues, csDataNames );',char(10),'',char(10),' sParName : new parameter column name',char(10),' cValues : values of new parameter column',char(10),' csDataNames : names of resulting data columns',char(10),'',char(10),'Note: ',char(10),' If field order is {''a1'',''a2'',''a3'',''b1'',''b2'',''b3''} then use',char(10),'',char(10),' sOut = sd.col2par(sIn,''numeric'',{''1'',''2'',''3''},{''a'',''b''});',char(10),'',char(10),' or',char(10),'',char(10),' sOut = sd.col2par(sIn,''numeric'',1:3,{''a'',''b''});',char(10),'',char(10),' This means that the new parameter field must be in interleaved',char(10),' order in the input data fields.',char(10),'',char(10),' Check consistency of mFields to avoid unexpected results.',char(10),'']);


function s = sd_compactval( s )
% remove unused entries from value vectors
%
% Author: Giso Grimm
% Date: 11/2008
  ;
  for kp=1:length(s.values)
    % first remove unused values:
    iidx = zeros(length(s.values{kp}),1);
    idx1 = unique(s.data(:,kp));
    idx = 1:length(idx1);
    iidx(idx1) = idx;
    s.values{kp} = s.values{kp}(idx1);
    s.data(:,kp) = iidx(s.data(:,kp));
    % now remove duplicates (without resorting):
    [s.values{kp},idx] = unique_unsorted_(s.values{kp});
    s.data(:,kp) = idx(s.data(:,kp));
  end

function [dout,idx] = unique_unsorted_( din )
  dout = din([]);
  idx = zeros(size(din));
  for k=1:numel(din)
    [ism,loc] = ismember(din(k),dout);
    if ~ism
      dout(end+1) = din(k);
      idx(k) = numel(dout);
    else
      idx(k) = loc;
    end
  end
  

function help_compactval
disp([' COMPACTVAL - remove unused entries from value vectors',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.compactval( s );',char(10),'',char(10),'',char(10),' Author: Giso Grimm',char(10),' Date: 11/2008',char(10),'']);


function sd_csv( data, fname )
% sd_csv - export data structure as CSV file
%
% Usage:
% sd_csv( data, fname )
%
  ;
  fh = fopen(fname,'w');
  s = '';
  for f=1:length(data.fields)
    s = sprintf('%s,"%s"',s,data.fields{f});
  end
  s(1) = [];
  fprintf(fh,'%s\n',s);
  for k=1:size(data.data,1)
    s = '';
    for f=1:length(data.values)
      if isnumeric(data.values{f})
	s = sprintf('%s,%g',s,data.values{f}(data.data(k,f)));
      else
	s = sprintf('%s,"%s"',s,data.values{f}{data.data(k,f)});
      end
    end
    for f=length(data.values)+1:size(data.data,2)
      s = sprintf('%s,%g',s,data.data(k,f));
    end
    s(1) = [];
    fprintf(fh,'%s\n',s);
  end
  fclose(fh);
  


function help_csv
disp([' CSV - sd_ - export data structure as  file',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  sd.csv( data, fname );',char(10),'',char(10),'',char(10),' Usage:',char(10),' sd_csv( data, fname )',char(10),'',char(10),'']);


function s = sd_deltaref( s, field, val )
% calculate difference to reference condition
% field : field number or name of reference paremeter
% val : value of reference condition
  s = sd_compactval( s );
  sField = sd_getfield( s, field );
  fieldvalues = sd_getvalues(s,field);
  sRef = sd_restrict( s, field, val );
  sRef = sd_par2col( sRef, field );
  Npar = numel(sRef.values);
  Ndata = numel(sRef.fields)-Npar;
  Nfields = numel(fieldvalues);
  fieldnames = s.fields(numel(s.values)+1:end);
  for k=1:numel(fieldnames)
    fieldnames{k} = ['d',fieldnames{k}];
  end
  dataRef = sRef.data(:,Npar+[1:Ndata]);
  s = sd_par2col( s, field );
  s.data(:,Npar+1:end) = ...
      s.data(:,Npar+1:end) - ...
      repmat(dataRef,[1,Nfields]);
  s = sd_reorder_datacol( s, Nfields );
  [s,mFields] = ...
      sd_col2par( s, sField, fieldvalues, fieldnames );
  s = sd_restrict( s, field, val, true );
  s = sd_compactval( s );


function help_deltaref
disp([' DELTAREF - calculate difference to reference condition',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.deltaref( s, field, val );',char(10),'',char(10),' field : field number or name of reference paremeter',char(10),' val : value of reference condition',char(10),'']);


function s = sd_eval( s, fun, varargin )
% evaluation of parameterized data
%
% Syntax:
%
% sOut = sd.eval( sIn, fun, ... )
%
% sIn  : structure containing a 'values' field (cell array, each
%        entry defines valid values in one dimension)
% fun  : evaluation function with one or more return values,
%        one input argument for each dimension, plus an optional
%        input argument for additional paramters 'par'.
%
% Optional param-value pairs:
%
% display  : flag to show progress information
% nrep     : number of re-evaluations, in case that 'fun' describes a
%            stochastic process
% brand    : bool: randomize trials
%            cell array of integer: keep given columns ordered
% structarg: pass parameter values as structure to eval function
% param    : additional parameters for 'fun'
%
% Author: Giso Grimm
% Date: 11/2006
  
  sPar = struct;
  sPar.display = 0;
  sPar.nrep = 1;
  sPar.brand = 0;
  sPar.structarg = 0;
  for k=1:2:length(varargin)-1
    sPar.(varargin{k}) = varargin{k+1};
  end
  if iscell( s )
    values = s;
    s = struct;
    s.values = values;
  end
  npar = length(s.values);
  ncond = 1;
  vnval = zeros(1,npar);
  ndata = nargout(fun);
  if ~isfield( s, 'fields' )
    s.fields = {};
    for k=1:npar
      s.fields{end+1} = sprintf('input%d',k);
    end
  end
  for k=1:ndata
    if numel(s.fields) < npar+k
      s.fields{end+1} = sprintf('output%d',k);
    end
  end
  for k=1:npar
    vnval(k) = length(s.values{k});
    ncond = ncond * vnval(k);
  end
  mpar = zeros(ncond,npar);
  kval = zeros(size(vnval));
  for kcond=1:ncond
    mpar(kcond,1:npar) = kval+1;
    kval = kval_step(kval,vnval);
  end
  mdata = zeros(ncond,ndata);
  if isnumeric(sPar.display) | islogical(sPar.display)
    if sPar.display
      h = waitbar(0,sprintf('%d conditions',ncond));
      h_tic = tic;
    end
  else
    sPar.display(0);
  end
  try
  s.data = zeros(0,npar+ndata);
  ktot = 0;
  for krep=1:sPar.nrep
    if iscell(sPar.brand) || sPar.brand
      if iscell(sPar.brand)
	[tmp,vCond] = sort(rand(1,ncond));
	[tmp,idx] = sortrows(mpar(vCond,cell2mat(sPar.brand)));
	vCond = vCond(idx);
      else
	[tmp,vCond] = sort(rand(1,ncond));
      end
    else
      vCond = [1:ncond];
    end
    for kcond=vCond
      ktot = ktot + 1;
      arg = cell(1,npar);
      disp_arg = '';
      if sPar.structarg
	sFunArg = struct;
      end
      for kpar=1:npar
	val = s.values{kpar}(mpar(kcond,kpar));
	if iscellstr(val)
	  val = val{:};
	end
	arg{kpar} = val;
	if sPar.structarg
	  sFunArg.(s.fields{kpar}) = val;
	end
	disp_arg = sprintf('%s%s:',disp_arg,any2string(arg{kpar}));
      end
      disp_arg = disp_arg(1:end-1);
      if ndata > 0
	sretval = sprintf('mdata(kcond,%d),',1:ndata);
	sretval = ['[',sretval(1:end-1),']='];
      else
	sretval = '';
      end
      sarg = sprintf('arg{%d},',1:npar);
      sarg = sarg(1:end-1);
      if isfield(sPar,'param')
	extrapar = ',sPar.param';
      else
	extrapar = '';
      end
      if sPar.structarg
	seval = sprintf('%sfun(sFunArg%s);',sretval,extrapar);
      else
	seval = sprintf('%sfun(%s%s);',sretval,sarg,extrapar);
      end
      eval(seval);
      if isnumeric(sPar.display) | islogical(sPar.display)
	if sPar.display
	  t_ac = toc( h_tic );
	  prog = ktot/(ncond*sPar.nrep);
	  tt = (t_ac/prog-t_ac)/(24*3600);
	  disp_arg(end+1) = ' ';
	  for kdat=1:ndata
	    disp_arg = sprintf('%s%1.3g:',disp_arg,mdata(kcond,kdat));
	  end
	  disp_arg(end) = [];
	  disp_arg = [disp_arg,' ',datestr(tt+now)];
	  disp(disp_arg);
	  waitbar(prog,h,sprintf('%d/%d conditions (ETA: %s)',ktot,ncond,datestr(tt,'HH:MM:SS')));
	end
      else
	sPar.display(ktot/(ncond*sPar.nrep));
      end
    end
    s.data = [s.data;[mpar mdata]];
  end
  if isnumeric(sPar.display) | islogical(sPar.display)
    if sPar.display
      if ishandle(h)
	close(h);
      end
    end
  end
  catch
    err = lasterror;
    if isnumeric(sPar.display) | islogical(sPar.display)
      if sPar.display
	close(h);
      end
    end
    rethrow(err);
  end
  
function x = kval_step( x, n )
  x(1) = x(1) + 1;
  for k=1:length(x)-1
    if x(k) >= n(k)
      x(k+1) = x(k+1)+1;
      x(k) = 0;
    end
  end
  
function s = any2string( x )
  if isnumeric(x)
    s = num2str(x);
  elseif ischar(x)
    s = x;
  else
    s = '???';
  end


function help_eval
disp([' EVAL - uation of parameterized data',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.eval( s, fun, varargin );',char(10),'',char(10),'',char(10),' Syntax:',char(10),'',char(10),' sOut = sd.eval( sIn, fun, ... )',char(10),'',char(10),' sIn  : structure containing a ''values'' field (cell array, each',char(10),'        entry defines valid values in one dimension)',char(10),' fun  : evaluation function with one or more return values,',char(10),'        one input argument for each dimension, plus an optional',char(10),'        input argument for additional paramters ''par''.',char(10),'',char(10),' Optional param-value pairs:',char(10),'',char(10),' display  : flag to show progress information',char(10),' nrep     : number of re-evaluations, in case that ''fun'' describes a',char(10),'            stochastic process',char(10),' brand    : bool: randomize trials',char(10),'            cell array of integer: keep given columns ordered',char(10),' structarg: pass parameter values as structure to eval function',char(10),' param    : additional parameters for ''fun''',char(10),'',char(10),' Author: Giso Grimm',char(10),' Date: 11/2006',char(10),'']);


function sData = sd_eval2( sData, fun, varargin )
% evaluation of parameterized data
%
% sData : structure containing a 'values' field (cell array, each
%         entry defines valid values in one dimension)
% fun   : evaluation function handle, of type
%         mOut = fun( sPar ) or 
%         mOut = fun( sPar, extra )
%         sPar is a structure with evaluation parameters
%         'extra' is the optional extra function parameter (see below)
%
% Optional param-value pairs:
%
% display  : flag to show progress information
% nrep     : number of re-evaluations, in case that 'fun' describes a
%            stochastic process
% brand    : bool: randomize trials
%            cell array of integer: keep given columns ordered
% param    : extra parameters for 'fun'
%
% Author: Giso Grimm
% Date: 11/2006, 3/2014
  
  sPar = struct;
  sPar.display = 0;
  sPar.nrep = 1;
  sPar.brand = 0;
  for k=1:2:length(varargin)-1
    sPar.(varargin{k}) = varargin{k+1};
  end
  npar = length(sData.values);
  ncond = 1;
  vnval = zeros(1,npar);
  for k=1:npar
    vnval(k) = length(sData.values{k});
    ncond = ncond * vnval(k);
  end
  mpar = zeros(ncond,npar);
  kval = zeros(size(vnval));
  for kcond=1:ncond
    mpar(kcond,1:npar) = kval+1;
    kval = kval_step2(kval,vnval);
  end
  if isnumeric(sPar.display) | islogical(sPar.display)
    if sPar.display
      h = waitbar(0,sprintf('%d conditions',ncond));
      h_tic = tic;
    end
  else
    sPar.display(0);
  end
  ktot = 0;
  mdata = [];
  sData.data = [];
  %% start of the evaluation loop:
  try
    for krep=1:sPar.nrep
      if iscell(sPar.brand) || sPar.brand
	if iscell(sPar.brand)
	  [tmp,vCond] = sort(rand(1,ncond));
	  [tmp,idx] = sortrows(mpar(vCond,cell2mat(sPar.brand)));
	  vCond = vCond(idx);
	else
	  [tmp,vCond] = sort(rand(1,ncond));
	end
      else
	vCond = [1:ncond];
      end
      for kcond=vCond
	ktot = ktot + 1;
	arg = cell(1,npar);
	disp_arg = '';
	sFunArg = struct;
	for kpar=1:npar
	  val = sData.values{kpar}(mpar(kcond,kpar));
	  if iscellstr(val)
	    val = val{:};
	  end
	  arg{kpar} = val;
	  sFunArg.(sData.fields{kpar}) = val;
	  disp_arg = sprintf('%s%s:',disp_arg,any2string2(arg{kpar}));
	end
	disp_arg = disp_arg(1:end-1);
	if isfield(sPar,'param')
	  tmpdata = fun( sFunArg, sPar.param );
	else
	  tmpdata = fun( sFunArg );
	end
	if isempty(mdata)
	  mdata = zeros(ncond,numel(tmpdata));
	end
	mdata(kcond,:) = tmpdata(:);
	if isnumeric(sPar.display) | islogical(sPar.display)
	  if sPar.display
	    t_ac = toc( h_tic );
	    prog = ktot/(ncond*sPar.nrep);
	    tt = (t_ac/prog-t_ac)/(24*3600);
	    disp_arg(end+1) = ' ';
	    for kdat=1:size(mdata,2)
	      disp_arg = sprintf('%s%1.3g:',disp_arg,mdata(kcond,kdat));
	    end
	    disp_arg(end) = [];
	    disp_arg = [disp_arg,' ',datestr(tt+now)];
	    disp(disp_arg);
	    waitbar(prog,h,sprintf('%d/%d conditions (ETA: %s)',ktot,ncond,datestr(tt,'HH:MM:SS')));
	  end
	else
	  sPar.display(ktot/(ncond*sPar.nrep));
	end
      end
      sData.data = [sData.data;[mpar mdata]];
    end
    if ~isfield( sData, 'fields' )
      sData.fields = {};
      for k=1:npar
	sData.fields{end+1} = sprintf('input%d',k);
      end
    end
    for k=1:size(mdata,2)
      if numel(sData.fields) < npar+k
	sData.fields{end+1} = sprintf('output%d',k);
      end
    end
    if isnumeric(sPar.display) | islogical(sPar.display)
      if sPar.display
	if ishandle(h)
	  close(h);
	end
      end
    end
  catch
    err = lasterror;
    if isnumeric(sPar.display) | islogical(sPar.display)
      if sPar.display
	close(h);
      end
    end
    rethrow(err);
  end
  
function x = kval_step2( x, n )
  x(1) = x(1) + 1;
  for k=1:length(x)-1
    if x(k) >= n(k)
      x(k+1) = x(k+1)+1;
      x(k) = 0;
    end
  end
  
function s = any2string2( x )
  if isnumeric(x)
    s = num2str(x);
  elseif ischar(x)
    s = x;
  else
    s = '???';
  end


function help_eval2
disp([' EVAL2 - evaluation of parameterized data',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  sData = sd.eval2( sData, fun, varargin );',char(10),'',char(10),'',char(10),' sData : structure containing a ''values'' field (cell array, each',char(10),'         entry defines valid values in one dimension)',char(10),' fun   : evaluation function handle, of type',char(10),'         mOut = fun( sPar ) or ',char(10),'         mOut = fun( sPar, extra )',char(10),'         sPar is a structure with evaluation parameters',char(10),'         ''extra'' is the optional extra function parameter (see below)',char(10),'',char(10),' Optional param-value pairs:',char(10),'',char(10),' display  : flag to show progress information',char(10),' nrep     : number of re-evaluations, in case that ''fun'' describes a',char(10),'            stochastic process',char(10),' brand    : bool: randomize trials',char(10),'            cell array of integer: keep given columns ordered',char(10),' param    : extra parameters for ''fun''',char(10),'',char(10),' Author: Giso Grimm',char(10),' Date: 11/2006, 3/2014',char(10),'']);


function s = sd_fun( s, kCol, fun )
% FUN - apply a function to a data column and add result as new
% column
%
% Usage:
% s = sdlib.fun( s, kCol, fun )
%
% s: struct data
% kCol: column number or name
% fun: function handle (must return numeric value)
%
% Author: Giso Grimm, 9/2010
  ;
  if ischar(kCol)
    kCol = strmatch(kCol,s.fields,'exact');
  end
  bPar = (kCol <= numel(s.values));
  if bPar
    vVal = s.values{kCol}(s.data(:,kCol));
  else
    vVal = s.data(:,kCol);
  end
  vRes = fun(vVal);
  s.fields{end+1} = func2str(fun);
  s.data(:,end+1) = vRes;

function help_fun
disp([' FUN - apply a ction to a data column and add result as new',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.fun( s, kCol, fun );',char(10),'',char(10),' column',char(10),'',char(10),' Usage:',char(10),' s = sdlib.fun( s, kCol, fun )',char(10),'',char(10),' s: struct data',char(10),' kCol: column number or name',char(10),' fun: function handle (must return numeric value)',char(10),'',char(10),' Author: Giso Grimm, 9/2010',char(10),'']);


function vDim = sd_getdim( s )
% STRUCT_DATA_GETDIM - return dimension of data
%
% Usage:
% vDim = sd_getdim( s )
%
% Author: Giso Grimm
% Date: 11/2008
  ;
  vDim = zeros(1,size(s.data,2));
  for k=1:length(vDim)
    vDim(k) = length(unique(s.data(:,k)));
  end


function help_getdim
disp([' GETDIM - STRUCT_DATA_return dimension of data',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  vDim = sd.getdim( s );',char(10),'',char(10),'',char(10),' Usage:',char(10),' vDim = sd_getdim( s )',char(10),'',char(10),' Author: Giso Grimm',char(10),' Date: 11/2008',char(10),'']);


function [v,field] = sd_getfield( s, field )
% return name and number of a field
% field : field number or field name
%
% Returns field name "v" and field number "field".
  ;
  if ischar( field )
    field = strmatch(field,s.fields,'exact');
  end
  if isempty(field)
    v = '';
  else
    v = s.fields{field};
  end


function help_getfield
disp([' GETFIELD - return name and number of a field',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  [v,field] = sd.getfield( s, field );',char(10),'',char(10),' field : field number or field name',char(10),'',char(10),' Returns field name "v" and field number "field".',char(10),'']);


function v = sd_getvalues( s, field )
% return value set of a given parameter field
% field : parameter field number or field name
  ;
  if ischar( field )
    field = strmatch(field,s.fields,'exact');
  end
  v = s.values{field};


function help_getvalues
disp([' GETVALUES - return value set of a given parameter field',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  v = sd.getvalues( s, field );',char(10),'',char(10),' field : parameter field number or field name',char(10),'']);


function sd_latex_tabular( s, format )
% sd_latex_tabular - print structured data as LaTeX
% tabular 
%
% Usage:
% sd_latex_tabular( s [, format ] )
%
% s : structured data
% format: optional format string (default: %g)
%
% Author: Giso Grimm
% Date: 12/2008
  ;
  if nargin < 2
    format = '%g';
  end
  data = s;
  s = '\begin{tabular}{';
  for f=1:length(data.values)
    s = sprintf('%sl',s);
  end
  for f=length(data.values)+1:length(data.fields)
    s = sprintf('%sc',s);
  end
  s = [s,'}'];
  disp(s);
  disp('\hline');
  s = '';
  for f=1:length(data.fields)
    s = sprintf('%s& %s ',s,data.fields{f});
  end
  s(1:2) = [];
  s = [s,'\\'];
  disp(s);
  disp('\hline');
  for k=1:size(data.data,1)
    s = '';
    for f=1:length(data.values)
      if isnumeric(data.values{f})
	s = sprintf(['%s & ',format],s,data.values{f}(data.data(k,f)));
      else
	s = sprintf('%s & %s',s,data.values{f}{data.data(k,f)});
      end
    end
    for f=length(data.values)+1:size(data.data,2)
      s = sprintf(['%s & ',format],s,data.data(k,f));
    end
    s(1:3) = [];
    s = [s,' \\'];
    disp(s);
  end
  disp('\hline');
  disp('\end{tabular}');

function help_latex_tabular
disp([' LATEX_TABULAR - sd_ - print structured data as LaTeX',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  sd.latex_tabular( s, format );',char(10),'',char(10),' tabular ',char(10),'',char(10),' Usage:',char(10),' sd_latex_tabular( s [, format ] )',char(10),'',char(10),' s : structured data',char(10),' format: optional format string (default: %g)',char(10),'',char(10),' Author: Giso Grimm',char(10),' Date: 12/2008',char(10),'']);


function s = sd_merge( s, varargin )
% merge multiple data structures into one
%
% s : data structure
% varargin : one or more other data structures
%
% requires field names and parameter types to be equal for all
% structures.
  for k=1:numel(varargin)
    so = varargin{k};
    if ~isequal(s.fields,so.fields)
      error('field names mismatch');
    end
    if numel(s.values) ~= numel(so.values)
      error('different number of parameters');
    end
    for kf=1:numel(s.values)
      if ~isequal(class(s.values{kf}),class(so.values{kf}))
	error('parameter types mismatch');
      end
    end
    for kf=1:numel(s.values)
      so.data(:,kf) = so.data(:,kf) + numel(s.values{kf});
      s.values{kf} = [s.values{kf},so.values{kf}];
    end
    s.data = [s.data;so.data];
  end
  s = sd_compactval( s );

function help_merge
disp([' MERGE - multiple data structures into one',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.merge( s, varargin );',char(10),'',char(10),'',char(10),' s : data structure',char(10),' varargin : one or more other data structures',char(10),'',char(10),' requires field names and parameter types to be equal for all',char(10),' structures.',char(10),'']);


function s = sd_mergepar( s, vCol )
% merge multiple parameter columns
%
% s : struct data
% vCol : number of clumns or cell array of column names
  ;
  if iscellstr( vCol )
    v = zeros(size(vCol));
    for k=1:numel(vCol)
      v(k) = strmatch(vCol{k},s.fields,'exact');
    end
    vCol = v;
  end
  fn = '';
  for kPar=vCol
    fn = [fn,s.fields{kPar},','];
    if isnumeric(s.values{kPar})
      cs = {};
      for kVal=1:numel(s.values{kPar})
	cs{end+1} = num2str(s.values{kPar}(kVal));
      end
      s.values{kPar} = cs;
    end
  end
  fn(end) = '';
  csVal = cell(1,size(s.data,1));
  for k=1:size(s.data,1)
    csVal{k} = '';
    for kPar=vCol
      csVal{k} = [csVal{k},s.values{kPar}{s.data(k,kPar)},','];
    end
    csVal{k}(end) = '';
  end
  s.fields(vCol) = [];
  s.fields = [{fn},s.fields];
  s.data(:,vCol) = [];
  s.data = [[1:size(s.data,1)]',s.data];
  s.values(vCol) = [];
  s.values = [{csVal},s.values];
  s = sd_compactval( s );

function help_mergepar
disp([' MERGEPAR - merge multiple parameter columns',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.mergepar( s, vCol );',char(10),'',char(10),'',char(10),' s : struct data',char(10),' vCol : number of clumns or cell array of column names',char(10),'']);


function s = sd_par2col( s, kPar )
% convert a parameter field into additional data columns
% s  : data structure
% kPar : number or name of parameter column
%
%Example:
% sIn.fields = {'p','numeric','a','b'};
% sIn.values = {{'X','Y'},[1:3]};
% sIn.data = [...
%  1, 1, 0.81, 0.27;...
%  2, 1, 0.90, 0.54;...
%  1, 2, 0.12, 0.95;...
%  2, 2, 0.91, 0.96;...
%  1, 3, 0.63, 0.15;...
%  2, 3, 0.09, 0.97;...
% ];
% sOut = sd.par2col( sIn, 'numeric' );
%
%Note:
% This operation can not be inverted by col2par. The fields 
% need to be reordered first.
%
%Author: 
% Giso Grimm, 12/2008
  if ischar(kPar)
    kPar = strmatch(kPar,s.fields,'exact');
  end
  if prod(size(kPar))~= 1
    error('invalid parameter');
  end
  s = sd_compactval( s );
  % constants:
  nPar = length(s.values);
  nFields = length(s.fields);
  nData = nFields-nPar;
  vVal = s.values{kPar};
  % remove control column from parameter block:
  par_out = s.data(:,1:nPar);
  par_out(:,kPar) = [];
  par_out = unique(par_out,'rows');
  nEntrNew = size(par_out,1);
  % check the dimensions:
  if nEntrNew * numel(s.values{kPar}) ~= size(s.data,1)
    disp('s.fields');
    s.fields
    sd_getdim(s)
    disp('size(s.data,1)');
    disp(size(s.data,1));
    nEntrNew
    disp('s.values{kPar}');
    disp(s.values{kPar});
    warning('Dimension mismatch');
  end
  data_out = zeros(nEntrNew,nData*length(vVal));
  data_out(:) = nan;
  sFields = {};
  for k=1:length(vVal)
    % create new field names:
    if iscell(vVal)
      sVal = vVal{k};
    else
      sVal = num2str(vVal(k));
    end
    for kf=1:nData
      sFields{end+1} = sprintf('%s, %s',s.fields{kf+nPar},sVal);
    end
    % select data subset:
    sTmp = sd_restrict(s, kPar, k );
    % remove control field from parameter set:
    mpar = sTmp.data(:,1:nPar);
    mpar(:,kPar) = [];
    if size(unique(mpar,'rows'),1) ~= size(mpar,1)
      error(['duplicate parameters for field ',...
	     s.fields{kPar},'=',sVal]);
    end
    %
    for kd=1:size(mpar,1)
      idx = find(ismember(par_out,mpar(kd,:),'rows'));
      data_out(idx,[1:nData]+(k-1)*nData) = sTmp.data(kd,nPar+1:end);
    end
  end
  s.fields = s.fields(1:nPar);
  s.fields(kPar) = [];
  s.values(kPar) = [];
  s.fields = [s.fields,sFields];
  s.data = [par_out,data_out];

function help_par2col
disp([' PAR2COL - convert a parameter field into additional data columns',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.par2col( s, kPar );',char(10),'',char(10),' s  : data structure',char(10),' kPar : number or name of parameter column',char(10),'',char(10),'Example:',char(10),' sIn.fields = {''p'',''numeric'',''a'',''b''};',char(10),' sIn.values = {{''X'',''Y''},[1:3]};',char(10),' sIn.data = [...',char(10),'  1, 1, 0.81, 0.27;...',char(10),'  2, 1, 0.90, 0.54;...',char(10),'  1, 2, 0.12, 0.95;...',char(10),'  2, 2, 0.91, 0.96;...',char(10),'  1, 3, 0.63, 0.15;...',char(10),'  2, 3, 0.09, 0.97;...',char(10),' ];',char(10),' sOut = sd.par2col( sIn, ''numeric'' );',char(10),'',char(10),'Note:',char(10),' This operation can not be inverted by col2par. The fields ',char(10),' need to be reordered first.',char(10),'',char(10),'Author: ',char(10),' Giso Grimm, 12/2008',char(10),'']);


function s = sd_permval( s, field, vPerm )
% permute value order in a given column
%
% s: struct data
% field: name or number of column
% vPerm: permutation vector
%
% Author: Giso Grimm 10/2010
  if ischar(field)
    field = strmatch(field,s.fields,'exact');
  end
  if numel(vPerm) ~= numel(s.values{field})
    error('dimension mismatch');
  end
  [tmp,idx] = sort(vPerm);
  s.values{field} = s.values{field}(vPerm);
  s.data(:,field) = idx(s.data(:,field));
  

function help_permval
disp([' PERMVAL - permute value order in a given column',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.permval( s, field, vPerm );',char(10),'',char(10),'',char(10),' s: struct data',char(10),' field: name or number of column',char(10),' vPerm: permutation vector',char(10),'',char(10),' Author: Giso Grimm 10/2010',char(10),'']);


function [fh, fname, ph] = sd_plot( sData, xidx, yidx, sPlotPars, varargin )
% plot data from data structures
%
% Mandatory paramaters:
%  sData  : Data structure with fields 'fields', 'values' and 'data'
%           (additional fields are ignored)
%  xidx   : column number of X-data
%  yidx   : column number of Y-data
%
% Optional parameters:
%  sPlotPars  : plot parameter structure, with optional fields:
%                - fontsize (14)
%                - markersize (fontsize/1.8)
%                - linewidth (1)
%                - gridfreq (1)
%                - firstgrid (1)
%                - colors ({'b','g','r','k','m','c','y'})
%                - linestyles ({'-','--','-.',':','-','-','-'})
%                - markers ({'d','x','*','o','+','*','d'})
%                - errorscale (1)
%                - xshift (0)
%
% Possible optional parameters (tag-value-pairs) :
%   'average'     : 'mean' or 'median' (mean)
%   'restrictions': list of data restrictions
%   'parameter'   : column number of parameter field
%   'xorder'      : re-ordering index vector
%   'errorscale'  : error scale (1)
% 
% Return values:
%  fh    : figure handle
%  fname : Unique file name containing information on data selection 
%
% Author: Giso Grimm
% Date: 11/2006
% Modified: 6/2007
  ;
  if nargin < 4
    sPlotPars = struct;
  end
  sAnalysisPar = struct();
  for k=1:length(varargin)/2
    sAnalysisPar.(varargin{2*k-1}) = varargin{2*k};
  end
  if ischar( xidx )
    xidx = strmatch(xidx,sData.fields,'exact');
  end
  if iscell( yidx )
    csY = yidx;
    yidx = [];
    for k=1:numel(csY)
      yidx = [yidx,strmatch(csY{k},sData.fields,'exact')];
    end
  end
  if ischar( yidx )
    yidx = strmatch(yidx,sData.fields,'exact');
  end
  sAnalysisPar = default_field( sAnalysisPar, 'average', 'mean' );
  sAnalysisPar = default_field( sAnalysisPar, 'restrictions', {} );
  sAnalysisPar = default_field( sAnalysisPar, 'parameter', [] );
  sAnalysisPar = default_field( sAnalysisPar, 'xorder', [] );
  sAnalysisPar = default_field( sAnalysisPar, 'errorscale', 1 );
  if strcmp(sAnalysisPar.average,'median')
    sAnalysisPar = default_field( sAnalysisPar, 'statfun', @avgfun_median );
  else
    sAnalysisPar = default_field( sAnalysisPar, 'statfun', @avgfun_mean );
  end
  if ischar( sAnalysisPar.parameter )
    sAnalysisPar.parameter = strmatch(sAnalysisPar.parameter,sData.fields,'exact');
  end
  sPlotPars = default_plot_pars( sPlotPars );
  restrictions = sAnalysisPar.restrictions;
  xorder = sAnalysisPar.xorder;
  pidx = sAnalysisPar.parameter;
  d = sData.data;
  [d, restrictions] = apply_restrictions( d, restrictions, sData );
  sAnalysisPar = default_field( sAnalysisPar, 'xlabel', sprintf('%s ',sData.fields{xidx}) );
  sAnalysisPar = default_field( sAnalysisPar, 'ylabel', sData.fields(yidx));
  x_name = sAnalysisPar.xlabel;
  y_name = sprintf('%s ',sData.fields{yidx});
  par_name = sprintf('%s ',sData.fields{pidx});
  fname = sprintf('%s_%s_%s_%s',y_name,x_name,par_name,restrictions);
  fname = tofilename(fname);
  vpar = unique( d(:,pidx) );
  fh = figure('PaperType','A4','Name',fname,'MenuBar','none');
  set(fh,'UserData',sPlotPars);
  nplots = length(yidx);
  ph = [];
  for kpl=1:nplots
    hax = subplot(nplots,1,kpl);
    pos = get(hax,'Position');
    set(hax,'Position',pos.*[1 1 0.74 1],'Tag','sd_ax');
    [tmp,vph] = ...
	sub_plot_data( d, xidx, yidx(kpl), pidx, xorder, ...
		       sData, sAnalysisPar, kpl);
    ph = [ph;vph];
    if kpl==1
      h = title(restrictions);
      set(h,'Interpreter','none','fontsize',sPlotPars.fontsize,'units','normalized',...
	    'horizontalalignment','left','position',[0 1.03 1]);
    end
    if kpl==nplots
      h = xlabel(x_name,'interpreter','none');
      set(h,'fontsize',sPlotPars.fontsize,'fontweight','bold');
    end
  end
  if ~isempty(pidx)
    csLeg = sData.values{pidx}(vpar);
    csLeg = any2cell( csLeg );
    h = legend(csLeg,'Interpreter','none','Location','NorthEast');
    set(get(h,'title'),'string',par_name,'interpreter','none',...
		      'fontsize',sPlotPars.fontsize,'fontweight','bold',...
		      'position',[0.5 1.02 1]);
    set(h,'Position',[0.73 0.05 0.19 0.12]);
    set(h,'Position',[0.73 0.05 0.19 0.12]);
    set(findobj(h,'type','line'),'linewidth',0.8);
  end
  
function s = default_plot_pars( s )
  s = default_field( s, 'fontsize', 14 );
  s = default_field( s, 'markersize', s.fontsize/1.8 );
  s = default_field( s, 'linewidth', 1 );
  s = default_field( s, 'gridfreq', 1 );
  s = default_field( s, 'firstgrid', 1 );
  s = default_field( s, 'colors', {'b','g','r','k','m','c','y'} );
  s = default_field( s, 'linestyles', {'-','--','-.',':','-','-','-'} );
  s = default_field( s, 'markers', {'d','x','*','o','+','*','d'} );
  s = default_field( s, 'xshift', 0 );
  if ~iscell(s.linestyles)
    s.linestyles = {s.linestyles};
  end
  if ~iscell(s.markers)
    s.markers = {s.markers};
  end
  if ~iscell(s.colors)
    s.colors = {s.colors};
  end
  return
  
function s = default_field( s, sField, sVal )
  if ~isfield( s, sField )
    s.(sField) = sVal;
  end

function x = any2cell( x )
  if isnumeric(x)
    tmp = {};
    for k=1:numel(x)
      tmp{end+1} = num2str(x(k));
    end
    x = tmp;
  end
  return

function [d, str] = apply_restrictions( d, restrictions, sData )
  str = '';
  for cd=restrictions
    lcd = cd{:};
    didx = [];
    for key=lcd{2}
      didx = [didx;find(d(:,lcd{1})==key)];
    end
    d = d(didx,:);
    val = any2cell(sData.values{lcd{1}}(lcd{2}));
    val = sprintf('+%s',val{:});
    val = val(2:end);
    field = sData.fields{lcd{1}};
    if length(str) == 0
      str = sprintf('%s:%s',field,val);
    else
      str = sprintf('%s,%s:%s',str,field,val);
    end
  end
  if isempty(d)
    error('No data.');
  end
  
function [vpar,vph] = sub_plot_data( d, xidx, yidx, pidx, xorder, sData, ...
			       sAnalysisPar,kpl)
  vph = [];
  sPlotPars = get(gcf,'UserData');
  vy = d(:,yidx);
  vx = unique( d(:,xidx) );
  vpar = unique( d(:,pidx) );
  npar = max(1,length(vpar));
  nx = length(vx);
  if isempty( xorder )
    xorder = 1:nx;
  end
  mmean = zeros(nx,npar);
  mstdl = zeros(nx,npar);
  mstdu = zeros(nx,npar);
  %clinespec = {'b-d','g--x','r-.*','k:o','m-+','c-*','y-d'};
  for kpar=1:npar
    sLineSpec = [ ...
	sPlotPars.colors{1+mod(kpar-1,length(sPlotPars.colors))}, ...
	sPlotPars.linestyles{1+mod(kpar-1,length(sPlotPars.linestyles))}, ...
	sPlotPars.markers{1+mod(kpar-1,length(sPlotPars.markers))} ...
		];
    kxm = 0;
    for kx=xorder
      kxm = kxm + 1;
      if ~isempty(pidx)
	point_idx = find( (d(:,xidx)==vx(kx)) .* (d(:,pidx)==vpar(kpar)) );
      else
	point_idx = find( (d(:,xidx)==vx(kx)) );
      end
      data = vy(point_idx);
      [mmean(kxm,kpar),mstdl(kxm,kpar),mstdu(kxm,kpar)] = ...
	  sAnalysisPar.statfun(data);
    end
    mstdl = mstdl * sAnalysisPar.errorscale;
    mstdu = mstdu * sAnalysisPar.errorscale;
    dx = sPlotPars.xshift*(kpar-npar/2-0.5)*0.03;
    if any(mstdl(:,kpar))|any(mstdu(:,kpar))
      h = errorbar([1:length(vx)]+dx,mmean(:,kpar),mstdl(:,kpar),mstdu(:,kpar), ...
		   sLineSpec);
    else
      h = plot([1:length(vx)]+dx,mmean(:,kpar), ...
	       sLineSpec);
    end
    set(h,'Linewidth',sPlotPars.linewidth,...
	  'MarkerSize',sPlotPars.markersize);
    vph = [vph;h];
    hold on;
  end
  hold off;
  xlab = sData.values{xidx}(vx);
  xlab = xlab(xorder);
  xlab = any2cell( xlab(sPlotPars.firstgrid:sPlotPars.gridfreq:end) );
  set(gca,'xtick',sPlotPars.firstgrid:sPlotPars.gridfreq:length(vx),...
	  'xticklabel',xlab);
  h = ylabel(sAnalysisPar.ylabel{kpl},'interpreter','none');
  set(gca,'fontsize',sPlotPars.fontsize);
  set(h,'fontsize',sPlotPars.fontsize,'fontweight','bold');
  xlim([0.5 length(vx)+0.5]);
  

function s = tofilename( s )
  s(strfind(s,'+')) = '';
  s(strfind(s,' ')) = '';
  s(strfind(s,'.')) = '';
  s(strfind(s,',')) = '_';
  s(strfind(s,'/')) = '';
  s(strfind(s,sprintf('\n'))) = '_';
  s(strfind(s,'(')) = '';
  s(strfind(s,')')) = '';
  s(strfind(s,'[')) = '';
  s(strfind(s,']')) = '';
  s(strfind(s,'{')) = '';
  s(strfind(s,'}')) = '';
  s(strfind(s,':')) = '=';
  s(strfind(s,'''')) = '';
  s = strrep(s, 'SIIenhancementdB','SI');
  s = strrep(s, 'spectraldistortiondB','SD');
  s = strrep(s, 'degreeofdiffusiveness','DOD');
  s = strrep(s, 'environment','env');
  s = strrep(s, 'algorithm','alg');
  s = strrep(s, 'competingazimuth','caz');
  s = strrep(s, 'caz=a000diffuse','');
  s = strrep(s, 'a000','a0');
  s = strrep(s, 'a060','a60');
  s = strrep(s, 'desiredSNRdB','dSNR');
  s = strrep(s, 'DOD_env_dSNR_alg=coh1_','DODenvdSNR');
  %s = strrep(s, '_', '');
  s = strrep(s, 'caz=a60diffuse','');

function x = donothing( x, data )
  return
  
function [m,l,u] = avgfun_mean( x )
  m = mean(x);
  l = -std(x);
  u = std(x);
  
function [m,l,u] = avgfun_median( x )
  m = median(x);
  l = quantile(x,0.25)-m;
  u = quantile(x,0.75)-m;


function help_plot
disp([' PLOT - data from data structures',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  [fh, fname, ph] = sd.plot( sData, xidx, yidx, sPlotPars, varargin );',char(10),'',char(10),'',char(10),' Mandatory paramaters:',char(10),'  sData  : Data structure with fields ''fields'', ''values'' and ''data''',char(10),'           (additional fields are ignored)',char(10),'  xidx   : column number of X-data',char(10),'  yidx   : column number of Y-data',char(10),'',char(10),' Optional parameters:',char(10),'  sPlotPars  : plot parameter structure, with optional fields:',char(10),'                - fontsize (14)',char(10),'                - markersize (fontsize/1.8)',char(10),'                - linewidth (1)',char(10),'                - gridfreq (1)',char(10),'                - firstgrid (1)',char(10),'                - colors ({''b'',''g'',''r'',''k'',''m'',''c'',''y''})',char(10),'                - linestyles ({''-'',''--'',''-.'','':'',''-'',''-'',''-''})',char(10),'                - markers ({''d'',''x'',''*'',''o'',''+'',''*'',''d''})',char(10),'                - errorscale (1)',char(10),'                - xshift (0)',char(10),'',char(10),' Possible optional parameters (tag-value-pairs) :',char(10),'   ''average''     : ''mean'' or ''median'' (mean)',char(10),'   ''restrictions'': list of data restrictions',char(10),'   ''parameter''   : column number of parameter field',char(10),'   ''xorder''      : re-ordering index vector',char(10),'   ''errorscale''  : error scale (1)',char(10),' ',char(10),' Return values:',char(10),'  fh    : figure handle',char(10),'  fname : Unique file name containing information on data selection ',char(10),'',char(10),' Author: Giso Grimm',char(10),' Date: 11/2006',char(10),' Modified: 6/2007',char(10),'']);


function [ph,mN] = sd_plot_histo( s, c_par, c_val, nBins )
% PLOT_STRUCT_DATA_VAL_HISTO - Histogram plotting function
%
% Usage:
% plot_sd_val_histo( s, c_par, c_val )
%
% s     : data structure
% c_par : parameter column
% c_val : data column
%
% Author: Giso Grimm, 2007
  ;
  % compact the value vectors and remove unused entries:
  s = sd_compactval( s );
  % get or calculate bins:
  v_min = min(s.data(:,c_val));
  v_max = max(s.data(:,c_val));
  if nargin < 4
    nBins = 10;
  end
  if prod(size(nBins))==1
    dv = (v_max-v_min)/nBins;
    vBins = [v_min:dv:v_max];
  else
    vBins = nBins;
    nBins = length(vBins)-1;
  end
  % get histograms:
  cValues = s.values{c_par};
  mN = zeros(nBins,length(cValues));
  for k=1:length(cValues)
    idx = find(s.data(:,c_par)==k);
    vN = histc(s.data(idx,c_val),vBins);
    vN(end) = [];
    mN(:,k) = vN ./ sum(vN);
  end
  % plot the data:
  ph = plot(0.5*(vBins(1:end-1)+vBins(2:end)),mN);
  xlim([min(vBins) max(vBins)]);
  if isnumeric(cValues)
    cValuesO = {};
    for k=1:length(cValues)
      cValuesO{k} = sprintf('%g',cValues(k));
    end
    cValues = cValuesO;
  end
  legend(cValues,'Location','Best')
  title(s.fields{c_par});
  xlabel(s.fields{c_val});


function help_plot_histo
disp([' PLOT_HISTO - PLOT_STRUCT_DATA_VAL_HISTO - Histogram plotting function',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  [ph,mN] = sd.plot_histo( s, c_par, c_val, nBins );',char(10),'',char(10),'',char(10),' Usage:',char(10),' plot_sd_val_histo( s, c_par, c_val )',char(10),'',char(10),' s     : data structure',char(10),' c_par : parameter column',char(10),' c_val : data column',char(10),'',char(10),' Author: Giso Grimm, 2007',char(10),'']);


function s = sd_plotwizzard( s )
% PLOT_STRUCT_DATA_WIZZARD - Interactively create data plots based
% on structured data input.
%
% Usage:
% s = plot_sd_wizzard( s )
%
% s : structure containing the data
%
% Author: Giso Grimm
% Date: 11/2006
  fh = figure('NumberTitle','off','MenuBar','none',...
	      'Position',[250 400 740 620],...
	      'Name','Structured data plotting wizzard');
  set(fh,'UserData',s);
  %movegui(fh,'center');
  uicontrol('style','text','fontweight','bold',...
	    'string','Y fields',...
	    'position',[40 580 180 20]);
  uicontrol('style','text','fontweight','bold',...
	    'string','Y axis',...
	    'position',[270 580 180 20]);
  uicontrol('style','text','fontweight','bold',...
	    'string','Available fields',...
	    'position',[40 460 180 20]);
  uicontrol('style','text','fontweight','bold',...
	    'string','X axis',...
	    'position',[270 460 180 20]);
  uicontrol('style','text','fontweight','bold',...
	    'string','Average model',...
	    'position',[500 580 180 20]);
  uicontrol('style','text','fontweight','bold',...
	    'string','Parameter',...
	    'position',[270 370 180 20]);
  uicontrol('style','text','fontweight','bold',...
	    'string','Restrictions',...
	    'position',[270 280 180 20]);
  uicontrol('style','listbox','string',s.fields(length(s.values)+1:end),...
	    'Position',[40 500 180 80],'tag','avail_fields_y',...
	    'value',1);
  uicontrol('style','listbox','string',s.fields(1:length(s.values)),...
	    'Position',[40 110 180 350],'tag','avail_fields',...
	    'value',1);
  uicontrol('style','listbox','string',{},...
	    'Position',[270 500 180 80],'tag','ydata_selection');
  uicontrol('style','text','string','',...
	    'Position',[270 410 180 50],'tag','xdata_selection',...
	    'HorizontalAlignment','left');
  uicontrol('style','text','string','',...
	    'Position',[270 320 180 50],'tag','pdata_selection',...
	    'HorizontalAlignment','left');
  uicontrol('style','listbox','string',{},...
	    'Position',[270 200 180 80],'tag','restrictions',...
	    'Callback',@select_restriction);
  uicontrol('style','listbox','string',{},...
	    'Position',[270 110 180 80],'tag','restriction_vals',...
	    'Callback',@select_restriction_val);
  uicontrol('style','listbox','string',{'mean','median'},...
	    'Position',[500 500 180 80],'tag','average_model');
  uicontrol('style','PushButton','string','>>',...
	    'Position',[230 560 30 20],'callback',@add_y_data);
  uicontrol('style','PushButton','string','<<',...
	    'Position',[230 530 30 20],'callback',@rm_y_data);
  uicontrol('style','PushButton','string','>>',...
	    'Position',[230 440 30 20],'callback',@add_x_data);
  uicontrol('style','PushButton','string','<<',...
	    'Position',[230 410 30 20],'callback',@rm_x_data);
  uicontrol('style','PushButton','string','>>',...
	    'Position',[230 350 30 20],'callback',@add_p_data);
  uicontrol('style','PushButton','string','<<',...
	    'Position',[230 320 30 20],'callback',@rm_p_data);
  uicontrol('style','PushButton','string','>>',...
	    'Position',[230 260 30 20],'callback',@add_restriction);
  uicontrol('style','PushButton','string','<<',...
	    'Position',[230 230 30 20],'callback',@rm_restriction);
  uicontrol('style','PushButton','string','plot',...
	    'Position',[40 40 130 40],'callback',@plot_this);
  uicontrol('style','PushButton','string','quit',...
	    'Position',[240 40 130 40],'callback','uiresume(gcf)');
  %% plot style controls:
  uicontrol('style','frame','position',[470 100 260 280],...
	    'tag','plotpar');
  create_plotpar_ui( 'fontsize', 1, @validate_positive, 14 );
  create_plotpar_ui( 'markersize', 2, @validate_positive, 3 );
  create_plotpar_ui( 'linewidth', 3, @validate_positive, 1 );
  create_plotpar_ui( 'linestyles', 4, @validate_string_or_cellarray, '''''' );
  create_plotpar_ui( 'gridfreq', 5, @validate_positive, 1 );
  create_plotpar_ui( 'firstgrid', 6, @validate_positive, 1 );
  create_plotpar_ui( 'colors', 7, @validate_string_or_cellarray, '''''' );
  create_plotpar_ui( 'markers', 8, @validate_string_or_cellarray, '''''' );
  if isfield( s, 'datapars' )
    set_all_datapars( s.datapars, fh );
  end
  if isfield( s, 'plotpars' )
    set_all_plotpar_svals( s.plotpars, fh );
  end
  uiwait(fh);
  if ishandle(fh)
    s.datapars = get_data_pars( fh );
    plotpars = struct;
    for fn={'fontsize','markersize','linewidth','linestyles', ...
	    'gridfreq','firstgrid','colors','markers'}
      name = fn{:};
      plotpars = get_plotpar_sval( plotpars, name, fh );
    end
    s.plotpars = plotpars;
    close(fh);
  end
  if nargout == 0
    clear s
  end
  
  
  
function add_y_data(varargin)
  h_fields = findobj(gcf,'tag','avail_fields_y');
  h_ydata = findobj(gcf,'tag','ydata_selection');
  csfields = get(h_fields,'string');
  if length(csfields)
    val = get(h_fields,'value');
    field = csfields{val};
    csfields(val) = [];
    set(h_fields,'value',length(csfields),'string',csfields);
    csfields =  get(h_ydata,'string');
    csfields{end+1} = field;
    set(h_ydata,'string',csfields,'value',length(csfields));
  end
  
function rm_y_data(varargin)
  h_fields = findobj(gcf,'tag','avail_fields_y');
  h_ydata = findobj(gcf,'tag','ydata_selection');
  csfields = get(h_ydata,'string');
  if length(csfields)
    val = get(h_ydata,'value');
    field = csfields{val};
    csfields(val) = [];
    set(h_ydata,'value',length(csfields),'string',csfields);
    csfields =  get(h_fields,'string');
    csfields{end+1} = field;
    set(h_fields,'string',csfields,'value',length(csfields));
  end
    
function add_x_data(varargin)
  h_fields = findobj(gcf,'tag','avail_fields');
  h_xdata = findobj(gcf,'tag','xdata_selection');
  csfields = get(h_fields,'string');
  if length(csfields)
    if length(get(h_xdata,'String')) == 0
      val = get(h_fields,'value');
      field = csfields{val};
      csfields(val) = [];
      set(h_fields,'value',length(csfields),'string',csfields);
      set(h_xdata,'string',field);
    end
  end
  
function rm_x_data(varargin)
  h_fields = findobj(gcf,'tag','avail_fields');
  h_xdata = findobj(gcf,'tag','xdata_selection');
  field = get(h_xdata,'string');
  if length(field)
    set(h_xdata,'string','');
    csfields =  get(h_fields,'string');
    csfields{end+1} = field;
    set(h_fields,'string',csfields,'value',length(csfields));
  end
  
function add_p_data(varargin)
  h_fields = findobj(gcf,'tag','avail_fields');
  h_xdata = findobj(gcf,'tag','pdata_selection');
  csfields = get(h_fields,'string');
  if length(csfields)
    if length(get(h_xdata,'String')) == 0
      val = get(h_fields,'value');
      field = csfields{val};
      csfields(val) = [];
      set(h_fields,'value',length(csfields),'string',csfields);
      set(h_xdata,'string',field);
    end
  end
  
function rm_p_data(varargin)
  h_fields = findobj(gcf,'tag','avail_fields');
  h_xdata = findobj(gcf,'tag','pdata_selection');
  field = get(h_xdata,'string');
  if length(field)
    set(h_xdata,'string','');
    csfields =  get(h_fields,'string');
    csfields{end+1} = field;
    set(h_fields,'string',csfields,'value',length(csfields));
  end
  
function add_restriction(varargin)
  h_fields = findobj(gcf,'tag','avail_fields');
  h_ydata = findobj(gcf,'tag','restrictions');
  csfields = get(h_fields,'string');
  if length(csfields)
    val = get(h_fields,'value');
    field = csfields{val};
    csfields(val) = [];
    set(h_fields,'value',min(1,length(csfields)),'string',csfields);
    csfields =  get(h_ydata,'string');
    csfields{end+1} = field;
    set(h_ydata,'string',csfields,'value',length(csfields));
    select_restriction;
  end
  
function rm_restriction(varargin)
  h_fields = findobj(gcf,'tag','avail_fields');
  h_ydata = findobj(gcf,'tag','restrictions');
  csfields = get(h_ydata,'string');
  if length(csfields)
    val = get(h_ydata,'value');
    field = csfields{val};
    csfields(val) = [];
    set(h_ydata,'value',min(1,length(csfields)),'string',csfields);
    csfields =  get(h_fields,'string');
    csfields{end+1} = field;
    set(h_fields,'string',csfields,'value',length(csfields));
    select_restriction;
    k = get_restriction_idx( field );
    s = get(gcf,'UserData');
    s.restrictions(k) = [];
    set(gcf,'UserData',s);
  end
  
function k = get_restriction_idx( sRes )
  s = get(gcf,'UserData');
  kRes = strmatch(sRes,s.fields,'exact');
  if ~isfield(s,'restrictions')
    s.restrictions = {};
  end
  k = 0;
  for kResL=1:length(s.restrictions)
    cRes = s.restrictions{kResL};
    if cRes{1} == kRes
      k = kResL;
    end
  end
  if ~k
    s.restrictions{end+1} = {kRes,1};
    k = length(s.restrictions);
  end
  set(gcf,'UserData',s);
  return

function select_restriction(varargin)
  h_restr = findobj(gcf,'tag','restrictions');
  h_rval = findobj(gcf,'tag','restriction_vals');
  csRes = get(h_restr,'String');
  if length(csRes)
    kRes = get(h_restr,'Value');
    kRes = get_restriction_idx( csRes{kRes} );
    s = get(gcf,'UserData');
    set(h_rval,'String',s.values{s.restrictions{kRes}{1}},...
	       'Value',s.restrictions{kRes}{2});
  else
    set(h_rval,'String',{},'Value',0);
  end
  
function select_restriction_val(varargin)
  h_restr = findobj(gcf,'tag','restrictions');
  h_rval = findobj(gcf,'tag','restriction_vals');
  csRes = get(h_restr,'String');
  kRes = get(h_restr,'Value');
  kRes = get_restriction_idx( csRes{kRes} );
  s = get(gcf,'UserData');
  val = get(h_rval,'Value');
  s.restrictions{kRes}{2} = val;
  set(gcf,'UserData',s);
  
function sDataPar = get_data_pars( fh )
  sDataPar = struct;
  s = get(fh,'UserData');
  if ~isfield(s,'restrictions')
    s.restrictions = {};
  end
  h_ydata = findobj(fh,'tag','ydata_selection');
  h_xdata = findobj(fh,'tag','xdata_selection');
  h_pdata = findobj(fh,'tag','pdata_selection');
  ydata_name = get(h_ydata,'String');
  xdata_name = get(h_xdata,'String');
  pdata_name = get(h_pdata,'String');
  k_ydata = [];
  for sYdata=ydata_name'
    k_ydata(end+1) = strmatch(sYdata{:},s.fields,'exact');
  end
  k_xdata = strmatch(xdata_name,s.fields,'exact');
  k_pdata = strmatch(pdata_name,s.fields,'exact');
  sDataPar.y_data = k_ydata;
  sDataPar.x_data = k_xdata;
  sDataPar.par_data = k_pdata;
  sDataPar.restrictions = s.restrictions;


function plot_this(varargin)
  sDataPar = get_data_pars( gcf )
  s = get(gcf,'UserData');
  if ~isfield(s,'restrictions')
    s.restrictions = {};
  end
  h_ydata = findobj(gcf,'tag','ydata_selection');
  h_xdata = findobj(gcf,'tag','xdata_selection');
  h_pdata = findobj(gcf,'tag','pdata_selection');
  ydata_name = get(h_ydata,'String');
  xdata_name = get(h_xdata,'String');
  pdata_name = get(h_pdata,'String');
  k_ydata = [];
  for sYdata=ydata_name'
    k_ydata(end+1) = strmatch(sYdata{:},s.fields,'exact');
  end
  k_xdata = strmatch(xdata_name,s.fields,'exact');
  k_pdata = strmatch(pdata_name,s.fields,'exact');
  s_ydata = sprintf('%d ',k_ydata);
  s_ydata = s_ydata(1:end-1);
  sPlotPars = get_plot_params( gcf )
  s_restr = '';
  for k=1:length(s.restrictions)
    s_restr = sprintf('%s{%d,%d},',s_restr,s.restrictions{k}{1},s.restrictions{k}{2});
  end
  s_restr = s_restr(1:end-1);
  %pcmd = sprintf('plot_struct_data(s,%d,[%s],%d,{%s})',...
  %		 k_xdata,s_ydata, ...
  %		 k_pdata,...
  %		 s_restr);
  %  disp(pcmd);
  h_avg = findobj(gcf,'tag','average_model');
  avg_model = get(h_avg,'String');
  avg_model = avg_model{get(h_avg,'Value')};
  try
    sd_plot(s,k_xdata,k_ydata,sPlotPars,...
		     'parameter',k_pdata,...
		     'restrictions',s.restrictions,...
		     'average',avg_model);
  catch
    err = lasterror;
    disp(err.message);
    for k=1:length(err.stack)
      disp(sprintf('%s:%d %s\n',...
		   err.stack(k).file,...
		   err.stack(k).line,...
		   err.stack(k).name));
    end
    rethrow err;
  end
  
function sPlotPar = get_plot_params( fh )
  sPlotPar = struct;
  sPlotPar = set_plotpar_field( sPlotPar, 'fontsize', fh );
  sPlotPar = set_plotpar_field( sPlotPar, 'markersize', fh );
  sPlotPar = set_plotpar_field( sPlotPar, 'linewidth', fh );
  sPlotPar = set_plotpar_field( sPlotPar, 'gridfreq', fh );
  sPlotPar = set_plotpar_field( sPlotPar, 'firstgrid', fh );
  sPlotPar = set_plotpar_field( sPlotPar, 'colors', fh );
  sPlotPar = set_plotpar_field( sPlotPar, 'linestyles', fh );
  sPlotPar = set_plotpar_field( sPlotPar, 'markers', fh );
  
function sPlotParS = get_plotpar_sval( sPlotParS, name, fh )
  h = findall(fh,'tag',sprintf('plotpar_%s',name));
  sPlotParS.(name) = get(h,'String');
  
function set_all_plotpar_svals( sPlotParS, fh )
  for fn = fieldnames(sPlotParS)'
    name = fn{:};
    h = findall(fh,'tag',sprintf('plotpar_%s',name));
    set(h,'String',sPlotParS.(name));
  end
  
function sPlotPar = set_plotpar_field( sPlotPar, name, fh )
  h = findall(fh,'tag',sprintf('plotpar_%s',name));
  s = get(h,'String');
  if ~isempty(s)
    eval(sprintf('val=%s;',s));
    if ~isempty(val)
      sPlotPar.(name) = val;
    end
  end
  
  
function err = validate_string_or_cellarray( bo, varargin )
  s = get(bo, 'String' );
  if isempty( s )
    s = '''''';
  elseif strcmp([s(1) s(end)],'''''')
    s = s;
  elseif strcmp([s(1) s(end)],'{}')
    s = s;
  else
    s = ['''' s ''''];
  end
  set(bo, 'String', s );
  
function err = validate_positive( bo, varargin )
  s = get(bo, 'String' );
  v_def = get(bo,'UserData');
  try
    val = str2num(s);
    if isempty(val)
      val = v_def;
    end
  catch
    val = v_def;
  end
  if val < eps
    val = eps;
  end
  s = num2str(val);
  set(bo, 'String', s );

function create_plotpar_ui( name, idx, validator, default )
  pos = get(findall(gcf,'tag','plotpar'),'Position');
  x = pos(1)+10;
  y = pos(2)+pos(4)-10;
  uicontrol('style','text','string',name,...
	    'position',[x y-25*idx-2 85 20],...
	    'fontweight','bold','horizontalalignment','right');
  h = uicontrol('tag',sprintf('plotpar_%s',name),...
		'style','edit',...
		'position',[x+90 y-25*idx 150 20],...
		'callback',validator,...
		'userdata',default,...
		'BackgroundColor',[1 1 1]);
  validator(h);

function set_all_datapars( sPars, fh )
  s = get(fh,'UserData');
  % y axis:
  idx_yavail = 1:length(s.fields);
  idx_yavail(sPars.y_data) = [];
  idx_yavail(find(idx_yavail<=length(s.values))) = [];
  h_fields = findobj(fh,'tag','avail_fields_y');
  h_ydata = findobj(fh,'tag','ydata_selection');
  set(h_fields,'String',s.fields(idx_yavail),'Value',length(idx_yavail));
  set(h_ydata,'String',s.fields(sPars.y_data));
  % x axis:
  h_xdata = findobj(fh,'tag','xdata_selection');
  set(h_xdata,'String',s.fields(sPars.x_data));
  % p axis:
  h_pdata = findobj(fh,'tag','pdata_selection');
  set(h_pdata,'String',s.fields(sPars.par_data));
  % restrictions:
  s.restrictions = sPars.restrictions;
  h_rdata = findobj(fh,'tag','restrictions');
  vRestr = [];
  for k=1:length(s.restrictions)
    vRestr(end+1) = s.restrictions{k}{1};
  end
  set(h_rdata,'String',s.fields(vRestr));
  set(fh,'UserData',s);
  select_restriction;
  % remove used fields:
  idx_xavail = 1:length(s.fields);
  idx_xavail(find(idx_xavail==sPars.x_data)) = [];
  idx_xavail(find(idx_xavail==sPars.par_data)) = [];
  for k=1:length(vRestr)
    idx_xavail(find(idx_xavail==vRestr(k))) = [];
  end
  idx_xavail(find(idx_xavail>length(s.values))) = [];
  h_fields = findobj(fh,'tag','avail_fields');
  set(h_fields,'String',s.fields(idx_xavail),'Value',length(idx_xavail));


function help_plotwizzard
disp([' PLOTWIZZARD - PLOT_STRUCT_DATA_WIZZARD - Interactively create data plots based',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.plotwizzard( s );',char(10),'',char(10),' on structured data input.',char(10),'',char(10),' Usage:',char(10),' s = plot_sd_wizzard( s )',char(10),'',char(10),' s : structure containing the data',char(10),'',char(10),' Author: Giso Grimm',char(10),' Date: 11/2006',char(10),'']);


function [COMPARISON,MEANS,H,GNAMES] = sd_posthoc( sData, DataCol,vParCol)
% call multcompare for each factor
  [p,t,stats,terms] = sd_anovan(sData,DataCol,vParCol);
  %,'display','off'
  for k=1:numel(vParCol)
    figure
    [COMPARISON,MEANS,H,GNAMES] = ...
	multcompare(stats,'ctype','lsd','dimension',k,'estimate','anovan');
  end
  

function help_posthoc
disp([' POSTHOC - call multcompare for each factor',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  [COMPARISON,MEANS,H,GNAMES] = sd.posthoc( sData, DataCol,vParCol);',char(10),'',char(10),'']);


function s = sd_readxls( fname, labelrow, datarows, parcols, datacols )
% STRUCT_DATA_READXLS - read an xls spreadsheet and convert to structdata
%
% Usage:
% s = sd_readxls( fname, labelrow, datarows, parcols, datacols )
%
% Author: Giso Grimm, 9/2010
  ;
  [num,txt,raw] = xlsread(fname,1,'','basic');
  s = struct;
  s.fields = txt(labelrow,[parcols,datacols]);
  s.values = {};
  s.data = zeros(numel(datarows),numel(parcols)+numel(datacols));
  for k=1:numel(parcols)
    %vNumPar = num(datarows,parcols(k));
    %vTxtPar = txt(datarows,parcols(k));
    vRaw = raw(datarows,parcols(k));
    if iscellstr(vRaw)
      s.values{k} = vRaw;
    else
      s.values{k} = cell2mat(vRaw);
    end
    s.data(:,k) = 1:numel(datarows);
  end
  for k=1:numel(datacols)
    s.data(:,numel(parcols)+k) = cell2mat(raw(datarows,datacols(k)));
  end
  s = sd_compactval( s );

function help_readxls
disp([' READXLS - STRUCT_DATA_read an xls spreadsheet and convert to structdata',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.readxls( fname, labelrow, datarows, parcols, datacols );',char(10),'',char(10),'',char(10),' Usage:',char(10),' s = sd_readxls( fname, labelrow, datarows, parcols, datacols )',char(10),'',char(10),' Author: Giso Grimm, 9/2010',char(10),'']);


function s = sd_renamefield( s, field, newname )
% rename a data field
%
% s       : data structure
% field   : field name or number
% newname : new name
  if ischar( field )
    field = strmatch( field, s.fields, 'exact' );
  end
  s.fields{field} = newname;

function help_renamefield
disp([' RENAMEFIELD - rename a data field',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.renamefield( s, field, newname );',char(10),'',char(10),'',char(10),' s       : data structure',char(10),' field   : field name or number',char(10),' newname : new name',char(10),'']);


function [s,vOrder] = sd_reorder_datacol( s, vOrder )
% reorder data fields
% s : input data structure
% vOrder : new order (vector), or new stride (scalar)
  if prod(size(vOrder))==1
    Ndata = numel(s.fields)-numel(s.values);
    Npar = numel(s.values);
    N1 = vOrder;
    N2 = floor(Ndata/N1);
    if N1*N2 ~= Ndata
      error(sprintf('The number of data columns (%d) is not a multiple of vOrder (%d)',...
		    Ndata,N1));
    end
    vOrder = reshape([1:Ndata],N2,N1)';
    vOrder = Npar+vOrder(:)';
  end
  if any(vOrder<=numel(s.values))
    error('vOrder is containing param columns');
  end
  vOrder = [1:numel(s.values),vOrder(:)'];
  s.fields = s.fields(vOrder);
  s.data = s.data(:,vOrder);

function help_reorder_datacol
disp([' REORDER_DATACOL - reorder data fields',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  [s,vOrder] = sd.reorder_datacol( s, vOrder );',char(10),'',char(10),' s : input data structure',char(10),' vOrder : new order (vector), or new stride (scalar)',char(10),'']);


function s = sd_restrict( s, kField, vValueIdx, bInvert )
% select a data subset by applying restrictions
%
% s         : data structure
% kField    : array of field number indices, or
%             single field name
% vValueIdx : array of value indices, or 
%             cell array of arrays of values
% bInvert   : invert restrictions (keep unmatched values)
%
% Author: Giso Grimm, 2007
  if ischar(kField)
    sName = kField;
    kField = strmatch(sName,s.fields,'exact');
    if isempty(kField)
      error(sprintf('No field ''%s''.',sName));
    end
  end
  if ischar(vValueIdx)
    vValueIdx = {vValueIdx};
  end
  if nargin < 4
    bInvert = false;
  end
  if iscell(vValueIdx)
    cValues = vValueIdx;
    vValueIdx = [];
    for k=1:length(kField)
      cAvailVal = s.values{kField(k)};
      if iscell(cAvailVal)
	idx = strmatch(cValues{k},cAvailVal,'exact');
      else
	idx = find(cValues{k}==cAvailVal);
      end
      idx(end+1) = 0;
      vValueIdx(end+1) = idx(1);
    end
  end
  idx = find(ismember(s.data(:,kField),vValueIdx,'rows'));
  if bInvert
    idx = setdiff(1:size(s.data,1),idx);
  end
  s.data = s.data(idx,:);

function help_restrict
disp([' RESTRICT - select a data subset by applying ions',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.restrict( s, kField, vValueIdx, bInvert );',char(10),'',char(10),'',char(10),' s         : data structure',char(10),' kField    : array of field number indices, or',char(10),'             single field name',char(10),' vValueIdx : array of value indices, or ',char(10),'             cell array of arrays of values',char(10),' bInvert   : invert restrictions (keep unmatched values)',char(10),'',char(10),' Author: Giso Grimm, 2007',char(10),'']);


function s = sd_result2par( s, kField )
% convert a result column into a parameter column.
%
% s      : Data structure.
% kField : Field number or name to be converted.
%
% Author: Giso Grimm
% Date: 12/2008
  ;
  if ischar(kField)
    kField = strmatch(kField,s.fields,'exact');
  end
  if prod(size(kField)) ~= 1
    error('Invalid dimension of field number (e.g., invalid field name).');
  end
  if kField > size(s.data,2)
    error('Invalid field number (to large).');
  end
  nPars = length(s.values);
  if kField <= length(nPars)
    error('Field is already a parameter column.');
  end
  nData = size(s.data,2)-nPars;
  idx_n = setdiff(nPars+[1:nData],kField);
  
  s.values{end+1} = unique(s.data(:,kField));
  for k=1:size(s.data,1)
    s.data(k,kField) = find(s.values{end}==s.data(k,kField));
  end
  s.data = [s.data(:,1:nPars),s.data(:,kField),s.data(:,idx_n)];
  s.fields = [s.fields(1:nPars),s.fields(kField),s.fields(idx_n)];


function help_result2par
disp([' RESULT2PAR - convert a result column into a parameter column.',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.result2par( s, kField );',char(10),'',char(10),'',char(10),' s      : Data structure.',char(10),' kField : Field number or name to be converted.',char(10),'',char(10),' Author: Giso Grimm',char(10),' Date: 12/2008',char(10),'']);


function s = sd_rmcol( s, vField )
% remove columns from a data structure
%
% s      : data structure
% vField : column numbers or column name to delete (can be cell
%          string to delete multiple columns by name)
  ;
  if iscell( vField )
    for sF = vField
      s = sd_rmcol( s, sF{:} );
    end
    return
  end
  if ischar( vField )
    vField = strmatch(vField,s.fields,'exact');
  end
  nPar = length(s.values);
  vFieldPar = vField(find(vField<=nPar));
  s.fields(vField) = [];
  s.values(vFieldPar) = [];
  s.data(:,vField ) = [];

function help_rmcol
disp([' RMCOL - remove columns from a data structure',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.rmcol( s, vField );',char(10),'',char(10),'',char(10),' s      : data structure',char(10),' vField : column numbers or column name to delete (can be cell',char(10),'          string to delete multiple columns by name)',char(10),'']);


function s = sd_rminf( s )
% remove rows with inf values in data section
  ;
  subdata = s.data(:,(numel(s.values)+1):numel(s.fields));
  idx = find(~any(~isfinite(subdata),2));
  s.data = s.data(idx,:);

function help_rminf
disp([' RMINF - remove rows with inf values in data section',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.rminf( s );',char(10),'',char(10),'']);


function s = sd_rmnan( s )
% RMNAN - remove rows with NaN values in data section
%
% Usage:
% s = sd.rmnan(s);
  ;
  subdata = s.data(:,(numel(s.values)+1):numel(s.fields));
  idx = find(~any(isnan(subdata),2));
  s.data = s.data(idx,:);

function help_rmnan
disp([' RMNAN - remove rows with NaN values in data section',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.rmnan( s );',char(10),'',char(10),'',char(10),' Usage:',char(10),' s = sd.rmnan(s);',char(10),'']);


function [s,csFields,cValues] = sd_squeeze( s )
% remove singleton dimensions (parameter and data fields)
%
% Author: Giso Grimm
% Date: 11/2008
  ;
  vDim = sd_getdim( s );
  idx = find(vDim(1:length(s.values))==1);
  csFields = s.fields(idx);
  s.fields(idx) = [];
  cValues = {};
  for k=1:length(idx)
    val = s.values{idx(k)};
    if ~iscell(val)
      cValues{k} = val(s.data(1,idx(k)));
    else
      cValues{k} = val{s.data(1,idx(k))};
    end
  end
  s.values(idx) = [];
  s.data(:,idx) = [];
  

function help_squeeze
disp([' SQUEEZE - remove singleton dimensions (parameter and data fields)',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  [s,csFields,cValues] = sd.squeeze( s );',char(10),'',char(10),'',char(10),' Author: Giso Grimm',char(10),' Date: 11/2008',char(10),'']);


function s = sd_strrepval( s, field, pattern, replacement )
% replace strings in value list of one or more fields
%
% s: struct data
% field: column numbers or cellstr with field names, or string with
% field name
  
  if iscellstr( field )
    for sF = field
      s = sd_strrepval( s, sF{:}, pattern, replacement );
    end
    return
  end
  if ischar( field )
    field = strmatch(field,s.fields,'exact');
  end
  if numel(field) > 1
    for sF = field
      s = sd_strrepval( s, sF, pattern, replacement );
    end
    return
  end
  s.values{field} = strrep(s.values{field},pattern,replacement);
  

function help_strrepval
disp([' STRREPVAL - replace strings in value list of one or more fields',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.strrepval( s, field, pattern, replacement );',char(10),'',char(10),'',char(10),' s: struct data',char(10),' field: column numbers or cellstr with field names, or string with',char(10),' field name',char(10),'']);


function s = sd_struct2parstruct( sIn )
% struct2parstruct - convert field names of structure into param
% control structure
%
% Usage:
% s = sd_struct2parstruct( sIn )
% 
% Fieldnames of sIn are converted into content of 's.fields',
% contents of sIn are converted into content of 's.values'.
%
% Example:
% sIn.par1 = {'apple','orange','lemmon'}
% sIn.par2 = [1:3]
% s = sd.struct2parstruct( sIn )
%
  s = struct;
  s.fields = fieldnames(sIn)';
  s.values = {};
  for k=1:numel(s.fields)
    s.values{k} = sIn.(s.fields{k});
  end

function help_struct2parstruct
disp([' STRUCT2PARSTRUCT - - convert field names of structure into param',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  s = sd.struct2parstruct( sIn );',char(10),'',char(10),' control structure',char(10),'',char(10),' Usage:',char(10),' s = sd_struct2parstruct( sIn )',char(10),' ',char(10),' Fieldnames of sIn are converted into content of ''s.fields'',',char(10),' contents of sIn are converted into content of ''s.values''.',char(10),'',char(10),' Example:',char(10),' sIn.par1 = {''apple'',''orange'',''lemmon''}',char(10),' sIn.par2 = [1:3]',char(10),' s = sd.struct2parstruct( sIn )',char(10),'',char(10),'']);


function [s1, s2] = sd_uniquepar( s1, kField1, s2, kField2, func )
% sd_unify_param - combine parameter values and use common
% index
%
% Usage:
% [s1, s2] = sd_unify_param( s1, kField1, s2, kField2 [, func ] )
%
% s1     : first data structure
% kField1: field number in first structure to be merged
% s2     : second data structure
% kField2: field number in second structure to be merged
% func   : Merge function to be used (optional)
%          Typically '@intersect' (default) or '@union'.
%
% Author: Giso Grimm
% Date: 11/2008
  ;
  if nargin < 5
    % union or intersect
    func = @intersect;
  end
  vVal1 = s1.values{kField1};
  vVal2 = s2.values{kField2};
  if ~isequal(class(vVal1),class(vVal2))
    error('Parameter values are of different classes');
  end
  % get combined values and transform indicees:
  vVal = func(vVal1,vVal2);
  for k=1:size(s1.data,1)
    idx = strmatch( vVal1{s1.data(k,kField1)}, vVal, 'exact' );
    if isempty(idx)
      idx = nan;
    end
    s1.data(k,kField1) = idx;
  end
  for k=1:size(s2.data,1)
    idx = strmatch( vVal2{s2.data(k,kField2)}, vVal, 'exact' );
    if isempty(idx)
      idx = nan;
    end
    s2.data(k,kField2) = idx;
  end
  s1.data(find(~isfinite(s1.data(:,kField1))),:) = [];
  s2.data(find(~isfinite(s2.data(:,kField2))),:) = [];
  s1.values{kField1} = vVal;  
  s2.values{kField2} = vVal;
  


function help_uniquepar
disp([' UNIQUEPAR - sd_unify_param - combine parameter values and use common',char(10),'',char(10),' Usage:',char(10),'  sd = libsd();',char(10),'  [s1, s2] = sd.uniquepar( s1, kField1, s2, kField2, func );',char(10),'',char(10),' index',char(10),'',char(10),' Usage:',char(10),' [s1, s2] = sd_unify_param( s1, kField1, s2, kField2 [, func ] )',char(10),'',char(10),' s1     : first data structure',char(10),' kField1: field number in first structure to be merged',char(10),' s2     : second data structure',char(10),' kField2: field number in second structure to be merged',char(10),' func   : Merge function to be used (optional)',char(10),'          Typically ''@intersect'' (default) or ''@union''.',char(10),'',char(10),' Author: Giso Grimm',char(10),' Date: 11/2008',char(10),'']);


